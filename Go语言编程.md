# 第1章 初识Go语言

## 1.1 语言简史
- Go语言的第一个版本在2009年11月正式对外发布，第一个正式版本的Go语言于2012年3月28日正式发布。
- 基于Google对开源的一贯拥抱态度，Go语言也自然而然地选择了开源方式发布。

## 1.2 语言特性
Go语言作为一门全新的静态类型开发语言，拥有如下特性
- 自动垃圾回收
- 更丰富的内置类型
- 函数多返回值
- 错误处理
- 匿名函数与闭包
- 类型和接口
- 并发编程
- 反射
- 语言交互性

### 1.2.1 自动垃圾回收
- 所谓垃圾回收，即所有的内存分配动作都会被在运行时记录，同事任何对该内存的使用也都会被记录，然后垃圾回收期会对所有已经分配的内存进行跟踪监测，一旦发现有些内存已经不再被任何人使用，就阶段性的回收这些没人用的内存

### 1.2.2 更丰富的内置类型
- map字典类型，slice数组切片，不用引入包

### 1.2.3 函数多返回值
- 并不是每一个返回值都需要复制，没有明确复制的返回值会保持默认的空值。对返回值不关心的用占位符

### 1.2.4 错误处理
- defer，panic，recover

### 1.2.5 匿名函数和闭包
- 所有的函数也是值类型，可以作为参数传递。

### 1.2.6 类型和接口
- 引入了一个无比强大的”非侵入式”接口的概念。在C++中实现一个接口，首先定义该接口，并且将类型和接口紧密绑定，而Go里面避免了这个问题。

### 1.2.7 并发编程
- 通过使用goroutine而不是裸用操作系统的并发机制，以及使用消息传递来共享内存而不是使用共享内存来通信，Go语言让并发编程变得更加轻盈和安全。
- 通过在函数调用前使用关键词go，我们即可让函数以goroutine方式执行。goroutine是一种比线程更加轻盈、更省资源的协程。
- Go语言使用channel（通道）这个概念来轻巧地实现了CSP模型，使用方式类似Unix管道（pipe）概念，可以方便的跨goroutine的通信。
- 一个进程创建的所有goroutine运行在同一个内存地址空间中，如果goroutine不得不去访问共享内存变量，访问前应该先获取相应的读写锁。Go语言标准库中的sync包提供了完备的读写锁功能。

### 1.2.8 反射
- 通过反射，可以获取对象类型的详细信息，并可动态操作对象。最常用的场景是做对象的序列化

### 1.2.9 语言交互性
在Go代码中，可以按照Cgo的特定语法混合编写C语言代码，然后Cgo工具可以将这些混合的C代码提取并生成对于C功能的调用包装代码。

## 1.3 第一个Go程序
- fmt.Println("hello, world")

### 1.3.1 代码解读
- 每个Go源代码文件的开头都是一个package声明，表名该Go代码所属的包。要执行Go可执行程序，必须建立一个名字为main的包，并且在该包中包含一个叫main()的函数
- Go的main()不带参数，不能定义返回值。命令行传入的参数在os.Args变量中保存。
- 包声明后面是一些列的import语句，导入该程序所依赖的包
- func 函数名（参数列表）（返回值列表）{ // 函数体 }
- Go注释支持  /*块注释*/  // 行注释

### 1.3.2 编译环境准备
- go version

### 1.3.3 编译程序
- go run hello.go，编译、链接和运行3个步骤合并为一步
- go build hello.go     ./hello

## 1.4 开发工具选择
- 文本编辑工具：gedit
- 安装了GoClipse插件的Eclipse
- Vim/Emacs
- LiteIDE

## 1.5 工程管理
- 不需要写makefile，go build知道目标代码的编译结果应该是一个包还是一个可执行文件，并分析了import语句以了解包的依赖关系

## 1.6 问题追踪和调试

### 1.6.1 打印日志
- Printf()和Pringln()

### 1.6.2 GDB调试
- gdb calc

## 1.7 如何寻求帮助

### 1.7.1 邮件列表
- Go邮件组的地址为：http://groups.google.com/group/golang-nuts
- Go的中文邮件组为：http://groups.google.com/group/golang-china

### 1.7.2 网站资源
- 官方网站：http://golang.org
- Go资料：http://github.com/wonderfo/wonderfogo/wiki

# 第2章 顺序编程

## 2.1 变量

### 2.1.1 变量声明
- var 名字 类型
- var (v1 int v2 string)

### 2.1.2 变量初始化
- var v1 int = 10
- var v2 = 10
- v3 := 10
- Go语言是不折不扣的强类型语言（静态类型语言）

### 2.1.3 变量赋值
- 多重复值：i, j = j, i

### 2.1.4 匿名变量
- 不需要的函数返回值用_

## 2.2 常量

### 2.2.1 字面常量
- Go语言的字面常量是无类型的

### 2.2.2 常量定义
- 通过const关键字，可以给字面常量取一个友好的名字
- 可以限定类型，但非必须

### 2.2.3 预定义常量
- Go语言预定义了：true、false和iota
- iota是遇到const关键词就重置为0

### 2.2.4 枚举
- const(...)，里面的常理啊昂需要大写才能在包外可见

## 2.3 类型
- 布尔类型：bool
- 整形：int8、byte、int16、int、uint、uintptr等
- 浮点类型：float32、float64
- 复数类型：complex64、complex128
- 字符串：string
- 字符类型：rune
- 错误类型：error
- 指针：pointer
- 数组：array
- 切片：slice
- 字典：map
- 通道：chan
- 结构体：struct
- 接口：interface

### 2.3.1 布尔类型
- 布尔类型不接受其他非true/false

### 2.3.2 整形
- int和int32被认为两种不同的类型，编译器也不会做类型转化
- 支持常规整数运算，+、-、*、/和%
- 比较运算符，>、<、==、>=和!=
- 两个不同类型的整型数不能直接比较，各种类型的整型变量可以与字面常量进行比较
- 位运算：<<左移，>>右移，^异或，&与，|或，^x取反

### 2.3.3 浮点型
- 浮点类型采用IEEE-754标准的表达方式
- float32相当于C语言float类型，float64相当于double
- 字面小数赋值给变量默认float64
- 浮点数不是一种精确的表达方式，所以像整型那样==判断是不准确的，使用math.Fdim(f1, f2)<精度

### 2.3.4 复数类型
- 复数实际上是由两个实数（计算机中用浮点数表示）构成，一个实部，一个虚部
- complex64类型，3.2+12i，complex(3.2, 12)
- real(z)获得复数的实部，通过imag(z)获取复数的虚部

### 2.3.5 字符串
- var str string，声明一个字符串变量
- ch := str[0]，取字符串的第一个字符
- 字符串可以用类似数组下表方式获取，但不能在初始化后被修改
- Go编译器支持UTF-8的源代码文件格式
- 字符串常用操作，x + y字符串连接，len(s)字符串长度，s[i]取字符
- 字符串遍历，以字节数组的方式遍历，i<len(s); ch := str[i]，获取的是byte类型字符，另一种是Unicode字符遍历，for i, ch := range str，ch的类型是rune

### 2.3.6 字符类型
- 一个是byte（实际上是uint8的别名），代表UTF-8字符串的单个字节的值，另一个是rune，代表单个Unicode字符

### 2.3.7 数组
- [32]byte, [2*N]struct{x, y int32}, [1000]*float64, [3][5]int, [2][2][2]float64
- range可以快捷的遍历容器的元素，数组下标，元素的值
- Go语言中数组是一个值类型，所有的值类型变量在赋值和作为参数传递时都产生一次复制动作
- 定义并初始化一个数组，传入参数给函数，函数内部的数组修改不影响外面的数组

### 2.3.8 数组切片
- 乍一看，数组切片就像一个指向数组的指针，实际上它拥有自己的数组结构
  1. 一个指向原生数组的指针
  2. 数组切片中的元素个数
  3. 数组切片已分配的存储空间
- 基于数组，数组切片添加了一系列管理功能，可以随时动态扩充存放空间，并且可以被随意传递而不会导致锁管理的元素被重复复制
- 基于数组创建数组切片：var mySlice []int = myArray[:5], myArray[:]所有元素，myArray[:5]前5个元素，myArray[5:]从第5个元素开始的所有元素
- 直接创建数组切片，mySlice1 := make([]int, 5)：创建一个初始元素个数为5的数组切片，元素初始值为0；mySlice2 := make([]int, 5, 10)，创建一个初始元素个数为5的数组切片，元素初始值为0，并预留10个元素的存储空间。mySlice3 := []int(1, 2, 3, 4, 5)直接创建并初始化5个元素
- 操作数组的方法都适用于数组切片
- 如果知道最大存储能力为50，最好初始的时候就设置存储能力为50，避免内存空间的重复复制
- cap()返回数组切片分配空间大小，len()返回数组切片中当前存储元素的个数
- append可恶意增加末尾元素，append(mySlice, 1, 2, 3)
- mySlice2 := []int(8, 9, 10); mySlice = append(mySlice, mySlice2...)，...代表打散mySlice2的元素传入
- 基于Slice创建Slice，newSlice := oldSlice[:3]
- copy函数支持从一个数组切片复制到另外一个数组切片，copy(slice2, slice1)，只会按照其中较小的数组切片元素个数进行复制，复制slice1到slice2

### 2.3.9 map
- 在Go中，map不需要引入任何库
- map是一堆键值对的未排序集合
- 变量声明：var myMap map[string]PersonInfo
- 创建：myMap = make(map[string]PersonInfo)，也可以创建的时候指定存储能力，myMap = make(map[string]PersonInfo, 100)，创建并初始化：myMap = map[string]PersonInfo{"1234": PersonInfo{"1", "Jack", "Room 101"}}
- 元素赋值，myMap["1234"] = PersonInfo{"1", "Jack", "Room 101"}
- 元素删除：delete删除容器内的元素，delete(myMap, "1234")，如果map没有"1234"也没副作用，但传nil会导致程序抛出异常(panic)
- 元素查找，value, ok := myMap["1234"]，只需要判断ok就知道是否找到
