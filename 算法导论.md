# 第1章 算法在计算中的作用

## 1.1 算法
- 算法就是任何良定义的计算过程，该过程取某个值或者值的集合作为输入并产生某个值或值的集合作为输出。这样算法就是把输入换成输出的计算步骤的一个序列。
- 数据结构是一种存储和组织数据的方式，旨在便于访问和修改。
- NP完全问题，是否存在有效算法是未知的；如果任何一个NP完全问题存在有效算法，那么所有NP完全问题都存在有效算法；有几个NP完全问题类似于（但又不完全同于）一些有着一直有效算法的问题。

## 1.2 作为一种技术的算法
- 效率，归并排序nlgn在n很大的时候明显好于插入排序n*n

# 第2章 算法基础

## 2.1 插入排序
- 本书中我们通常将算法描述为用一种伪代码书写的程序，伪代码通常不关心软件工程问题，为了更简洁地表达算法的本质，常常忽略数据抽象、模块性和错误处理的问题。
- 循环不变式：初始化，循环的第一次迭代之前，它为真；保持，如果循环的某次迭代之前它为真，那么下次迭代之前它仍然为真。终止，在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。
- 伪代码的一些约定
  1. 缩进表示块结构
  2. while、for与repeat-until等循环结构以及if-else等条件结构与C、C++、Java、Python和Pascal中的那些结构具有类似解释
  3. 符号"//"后面表示注释
  4. 刑辱i=j=e多重赋值，将e给变量i和变量j
  5. 变量（如i、j和key）是局部与给定过程的
  6. 数组元素通过数组名[下表]这种形式访问
  7. 复合数据通常被组织成对象，的对象又由属性组成
  8. 我们按值把参数传递给过程，对象被传递时，指向表示对象数据的指针被复制
  9. 一个return语句立即将控制返回到调用过程的调用点
  10. 布尔运算符"and"和"or"都是短路的
  11. 关键词error表示因为已被调用的过程情况不对而出现了一个错误

## 2.2 分析算法
- 分析算法的结果意味着预测算法需要的资源。虽然有时我们主要关心像内存、通信带宽或计算机硬件这类资源，但是通常我们想度量的是计算时间。
- 在本书的余下分析中，我们往往集中于只求最坏情况运行时间
- 我们真正关心的是增长率或增长量级

## 2.3 设计算法
### 2.3.1 分治法
- 许多有用的算法是递归的，为了解决一个给定的问题，算法一次或多次递归地调用其自身以解决紧密相关的若干子问题。
- 分治思想：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解
- 归并排序符合分治模式
  1. 分解：分解待排序的n个元素的序列成各具n/2个元素的两个子序列
  2. 解决：使用归并排序递归地排序两个子序列
  3. 合并：合并两个已排序的子序列以产生已排序的答案
- MERGE(A, p, q, r），p<=q<r，假设A[p..q]和A[q+1..r]已排好序，那么合并两个子数组排序好替换A[p..r]

### 2.3.2 分析分治算法
- 当一个算法包含对其自身的递归调用时，我们往往可以用递归方程或递归式来描述其运行时间，改方程根据在较小输入上的运行时间来描述在规模为n的问题上的总运行时间
- 归并排序的时间复杂度O(nlgn)

# 第3章 函数的增长
- 当输入规模足够大，是的只有运行时间的增长量级有关时，我们要研究算法的渐进效率。

## 3.1 渐进符号
- 当只有一个渐近上界时候，用O记号

## 3.2 标准记号与常用函数
- 单调性
- 向下取整与向上取整
- 模运算
- 多项式
- 指数
- 对数
- 阶乘
- 多重函数
- 多重对数函数
- 斐波那契数

# 第4章 分治策略
## 4.1 最大子数组问题
