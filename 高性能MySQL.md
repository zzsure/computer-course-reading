# 第1章 MySQL架构与历史

## 1.1 MySQL逻辑架构
- 最上层：连接处理、授权认证、安全等等
- 第二层：所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等
- 第三层：存储引擎，负责MySQL中数据存取和提取

### 1.1.1 连接管理与安全性
- 每个客户端连接都会在服务器进程中拥有一个线程
- 连接到MySQL服务器后，服务器需要进行认证。然后查询是否有特定权限

### 1.1.2 优化与执行
MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，一级选择合适的索引等

## 1.2 并发控制
无论何时，只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题

### 1.2.1 读写锁
读锁是共享的，相互不阻塞的。写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁

### 1.2.2 锁粒度
- 一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。
- 表锁：它会锁定整张表，一个用户对表进行写操作（插入、删除、更新等）前，需要先获得写锁。会阻塞其他用户对该表的所有的读写操作
- 行级锁：可以最大程度的支持并发处理（同时也带来了最大的锁开销），行级锁只在存储引擎层实现

## 1.3 事务
- 事务就是一组原子性的SQL查询，或者说一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败。
- ACID表示原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）

### 1.3.1 隔离级别
- READ UNCOMMITTED（未提交读）：事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读
- READ COMMITED（提交读）：一个事务开始时，只能”看见“已经提交的事务所做的修改。也叫不可重复读
- REPEATABLE READ（可重复读）：保证了在同一个事务中多次读取同样记录的结果是一致的。无法解决幻读（当某个事务在读取某个范围的记录时，会产生幻行）的问题
- SERIALIZABLE（可串行读）：强制事务串行执行，避免了幻读问题

### 1.3.2 死锁
- 死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用资源，从而导致恶性循环的现象。
- InnoDB目前处理死锁的方法是，将持有最少行级排他锁进行回滚
- 死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。

### 1.3.3 事务日志
使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把改修改行为记录到持久在硬盘的事务日志中，而不用每次都将修改的数据本身持久到磁盘。如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写会磁盘，此时系统崩溃，存储引擎在重启时能够将自动恢复这部分修改的数据。

### 1.3.4 MySQL中的事务

#### 自动提交
默认方式，如果不是显示地开始一个事务，则每个查询都被当做一个事务执行提交操作。

#### 在事务中混合使用存储引擎
事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。

#### 隐式和显示锁定
InnoDB采用的是两阶段锁定协议。在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻释放。前面描述的锁定都是隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁。

## 1.4 多版本并发控制
- MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC）
- MVCC的实现是通过保存数据在某个时间点的快照来实现的。也就说，不管需要执行多长时间，每个事务看到的数据都是一致的。
- InnoDB的MVCC，是通过再每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间。当然存储的并不是实际的时间值，而是系统版本号。
- MVCC只在REPEATABLE READ和READ COMMITTED两个级别下工作

## 1.5 MySQL的存储引擎
可以用SHOW TABLE STATUS命令显示表的相关信息

### 1.5.1 InnoDB存储引擎
InnoDB是MySQL的默认事务型引擎

#### InnoDB的历史
InnoDB是一个很重要的存储引擎，很多个人和公司都对其贡献代码，而不仅仅是Oracle公司的开发团队。一些重要的贡献者包括Google、Yasufumi Kinoshita、Percona、Facebook等

#### InnoDB概览
- InnoDB的数据存储在表空间中，采用MVCC来支持高并发，并且实现了四个标准的隔离级别。默认级别是可重复读，并且通过间隙锁防止幻读出现，间隙锁不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。
- InnoDB使用聚簇索引，对主键查询有很高的性能，不过它的二级索引中必须包含主键列，所以如果索引比较多的话，主键应当尽可能的小
- InnoDB支持真正的热备份

### 1.5.2 MyISAM存储引擎
MyISAM不支持事务和行级锁，崩溃后无法安全恢复

#### 存储
- MyISAM会存储到数据文件和索引文件两个表
- MyISAM表可存储行记录数

#### MyISAM特性

- 加锁与并发：MyISAM对整张表加锁，而不是针对行
- 修复：可以手工或者自动执行检查和修复操作
- 索引特性：支持全文索引，这是一种基于分词创建的索引
- 延迟更新索引键：DELAY_KEY_WRITE，修改执行完成后，索引先写到内存中键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引快写入到磁盘。

#### MyISAM压缩表
如果表再创建并导入数据以后，不会在进行修改操作，可用压缩表

#### MyISAM性能
设计简单，数据以紧密格式存储，某些场景下性能很好。典型的性能问题是表锁问题

### 1.5.3 MySQL内建的其他存储引擎
- Archive引擎：只支持INSERT和SELECT操作，利用zlib对插入的行进行压缩，SELECT查询需要执行权标扫描。Archive表适合日志和数据采集类应用
- Blackhole引擎：丢弃所有插入数据，不做任何保存。可以用于复制数据到备库
- CSV引擎：可将CSV文件作为MySQL的表来处理
- Federated引擎：是访问其他MySQL服务器的一个代理
- Memory引擎：需要快速访问数据，数据不会修改，重启丢失也没问题的话，可以使用。
- Merge引擎：多个MyISAM表合并而来的虚拟表
- NDB集群引擎：作为SQL和NDB原生协议之间的接口

### 1.5.4 第三方存储引擎
- OLTP类引擎：改进点主要集中在性能、可测量性和操作灵活性方面
- 面向列的存储引擎：如果不需要整行数据，面向列的方式可以传输更少的数据
- 社区存储引擎：Aria解决了崩溃安全恢复问题的MyISAM，Groonga全文索引引擎，OQGraph支持图操作，Q4M实现了队列操作，SphinxSE全文索引服务器提供了SQL接口，Spider实现了分片，VPForMySQL实现了垂直分区，可将表分成不同列的组合

### 1.5.5 选择合适的引擎
- 除非需要InnoDB不具备的特性，否则都优先选择InnoDB。选择引擎需要考虑事务、备份、崩溃恢复、特有的特征来选择
- 日志型应用：比如apache将网站所有访问信息记录到表，只是记录日志，对插入速度有很高要求，选择MyISAM或者Archive
- 只读或者大部分情况下只读的表：用于编制类目或者分列清单，不介意MyISAM的崩溃恢复问题可选MyISAM
- 订单处理：支持事务是必要选项，对外键支持，InnoDB是最佳选择
- 电子公告牌和主题讨论论坛：流量突增后，查询非常慢，选MyISAM
- CD-ROM应用：选择MyISAM或者MyISAM压缩表，这样表之间可以隔离，并且可以再不同介质上互相拷贝
- 大数据量：单机数据量在3~5TB，InnoDB运行的还不错。如果10TB以上，需要建立数据仓库，Infobright最成功的解决方案，有的可能适合TokuDB

### 1.5.6 转化表的引擎

#### ALTER TABLE
MySQL会按行将数据从原表复制到一张新的表中，在复制期间可能会消耗系统所有的I/O能力，同时原表会加上读锁。

#### 导出与导入
mysqldump导出数据到文件，然后修改文件中CREATE TABLE语句的存储引擎选项，然后再导入

#### 创建与查询（CREATE和SELECT）
不需要导出整个表的数据，而是先创建一个新的存储引擎的表，然后利用INSERT...SELECT语句来导数据

## 1.6 MySQL时间线（Timeline）
MySQL 55可以说是MySQL历史上质量最高的版本，采用了InnoDB plugin的版本在高并发的时候性能明显更好。

## 1.7 MySQL的开发模式
MySQL依然遵循GPL开发协议，全部的源代码（除了一些商用版本的插件）都会开放给社区

## 1.8 总结
MySQL拥有分层架构，上层是服务器层的服务和查询执行引擎，下层则是存储引擎。虽然有很多不同作用的插件API，但存储引擎的API还是最重要的。如果能理解MySQL在存储引擎和服务层之间处理查询时如何通过API来回交互，就能抓住MySQL的核心基础架构和精髓。

# 第2章 MySQL基准测试
基准测试是针对系统设计的一种压力测试，通常的目标是为了掌握系统的行为。但也有其他原因，如重现某个系统状态，或者是做新硬件的可靠性测试。

## 2.1 为什么需要基准测试
因为基准测试是唯一方便有效的、可以学习系统在给定的工作负载下会发生什么的方法。基准测试可以观察系统在不同压力下的行为，评估系统的容量，掌握哪些是重要变化，或者观察系统如何处理不同的数据。基准测试可以再系统使肌肤在之外创造一些虚构场景进行测试。

## 2.2 基准测试的策略
两种主要的策略：一个是针对系统的整体测试 另外是单独测试MySQL

### 2.2.1 测试何种指标
- 吞吐量：指的是单位时间内的事务处理数。
- 响应时间或者延迟：测试任务所需的整体时间
- 并发性：需要关注的是正在工作中的并发操作，或者是同时工作的线程数或者连接数。当并发增加时，需要测量吞吐量是否下降，响应时间是否变长。如果是这样，应用可能无法处理峰值压力。
- 可扩展性：给系统增加一倍的工作，在理想情况下就能获得两倍的结果

## 2.3 基准测试方法

### 2.3.1 设计和规划基准测试
首先要获得生产数据集的快照，并且该快照很容易还原，以便进行后续的测试

### 2.3.2 基准测试应该运行多长时间
进准侧四应该运行足够的时间。等系统看起来稳定的时间至少等于系统预热的时间。

### 2.3.3 获取系统性能和状态
需要记录的数据包括系统状态和性能指标，诸如CPU使用率、磁盘I/O、网络流量统计、SHOW GLOBAL STATUS计数器等。

### 2.3.4 获得准确的测试结果
确认测试结果是否可重复

### 2.3.5 运行基准测试并分析结果
尽可能地使所有测试过程自动化，包括装载数据、系统预热、执行测试、记录结果等

### 2.3.6 绘图的重要性
使用gnuplot绘制图形，图形可以找出性能尖刺。

## 2.4 基准测试工具
### 2.4.1 集成式测试工具
- ab：Apache HTTP服务器基准测试工具。它可以测试HTTP服务器每秒最多可以处理多少请求。
- http_load：可以通过一个输入文件提供多个URL，进行随机测试
- JMeter：虽然是设计测试Web应用的，但也可以用于测试其他诸如FTP服务器，或者通过JDBC进行数据库查询测试

### 2.4.2 单组件式测试工具
- mysqlslap：可以模拟服务器的负载，并输出计时信息
- MySQL Benchmark Suite(sql-bench)：主要用于测试服务器执行查询的速度
- Super Smack：用于MySQL和Post过热SQL的基准测试工具，可以提供压力测试和负载生成
- Database Test Suite：类似某些工业标准测试的测试工具集
- Percona's TPCC-MySQL Tool：类似TPC-C的基准测试工具集
- sysbench：一款多线程系统压测工具
- MySQL内置的BENCHMARK()函数，可以测试某些特定操作的执行速度

## 2.5 基准测试案例

### 2.5.1 http_load
- http_load -parallel 1 -seconds 10 urls.txt
- 模拟同时有5个并发用户：http_load -parallel 5 -seconds 10 urls.txt
- 模拟访问的请求率（比如每秒5次）来压力测试：http_load -rate 5 -seconds 10 urls.txt

### 2.5.2 MySQL基准测试套件
- MySQL Benchmark Suite，在MySQL安装目录的sql-bench子目录中包含该工具
- 运行全部测试：./run-all-tests --server=mysql --user=root --log --fast
- 只进行insert测试：./test-insert

### 2.5.3 sysbench
- sysbench可以执行多种类型的基准测试，不仅设计用来测试数据库的性能，也可以测试运行数据库的服务器的性能
- sysbench的CPU基准测试：计算素数直到某个最大值所需要的时间，sysbench --test=cpu --cpu-max-prime=20000 run
- sysbench的文件I/O基准测试，可以测试系统在不同I/O负载下的性能，对于比较不同的磁盘驱动器、不同的RAID卡、不同的RAID模式很有帮助。测试的数据要比内存大，sysbench --test=fileio --file-total-size=150G prepare来创建数据集，运行文件I/O混合随机读/写基准测试：sysbench --test=fileio --file-total-size=150G --file-test-mode=rndrw --init-rng=on --max-time=300 --max-requests=0 run，可看出每秒请求书和总吞吐量等。sysbench --test=fileio --file-total-size=150G cleanup清除测试文件。
- sysbench的OLTP基准测试：OLTP模拟了一个简单的失误处理系统的工作负载。测试后结果包含总的事务数，每秒事务数，时间统计信息，线程公平性统计信息
- sysbench其他特征，和数据库没关系。内存：测试内存的连续读写性能。线程：测试线程调度器的性能。互斥锁：测试互斥锁的性能。顺序写：测试顺序写的性能。

### 2.5.4 数据库测试套件中的dbt2 TPC-C测试
- TPC-C是TPC组织发布的一个测试规范，用于模拟测试复杂的在线事务处理系统（OLTP），它的测试结果包括每分钟事务数（tpmC），以及每事务的成本（Price/tpmC）

### 2.5.5 Percona的TPCC-MySQL测试工具
- sysbench的测试很简单，结果也具有可比性，但无法模拟真实业务的压力
- TPC-C测试能模拟真实压力，dbt2是TPC-C的一个很好实现，但没有得到TPC组织认可
- 本书作者开发了Percona，建立数据库和表结构、加载数据、执行测试

# 第3章 服务器性能剖析
- 最常碰到的三个性能相关的服务请求是：如何确认服务器是否达到了性能最佳的状态、找出某条语句为什么执行不够快，以及诊断被用户描述成“停顿”、“堆积”或者“卡死”的某些间歇性疑难故障

## 3.1 性能优化简介
- 我们将性能定义为完成某件任务所需要的时间度量，换句话说，性能就是响应时间
- 假设性能优化就是再一定的工作负载下尽可能地降低响应时间
- 很多人在优化时，都将精力放在修改一些东西上，缺很少去进行精确的测量，我们的做法完全相反，将花费非常多，甚至90%的时间来测量响应时间花哪里，然后对症下药
- 有两种比较常见的情况导致不合适的测量，在错误的时间启动和停止测量。测量的是聚合后的信息，而不是目标活动本身

### 3.1.1 通过性能剖析进行优化
- 性能剖析一般有两个步骤：测试任务所花费的时间；然后对结果进行统计和排序，将重要的任务排在前面
- 基于执行时间的分析研究的是什么任务的执行时间最长，而基于等待的分析是判断任务在什么地方被阻塞的时间最长

### 3.1.2 理解性能剖析
- 值得优化的查询：一些只占总相应时间比重很小的查询是不值得优化的
- 异常情况：某些任务即使没有出现在性能剖析输出的前面也需要优化，比如某些任务执行次数很少，但每次执行都非常慢，严重影响用户体验
- 未知的未知：丢失的时间是指任务的总时间和实际测量到的时间之间的差
- 被掩藏的细节：无法显示所有相应时间的分布，只相信平均值是非常危险的。医院所有病人的平均体温是没有任何价值的

## 3.2 对应用程序进行性能剖析
- 建议在所有的项目中都考虑包含性能剖析的代码。往已有的项目中加入性能剖析代码也许很困难，新项目就简单一些。
- 大多数设计和构建过高性能应用程序的人相信，应该尽可能地测量一切可以测量的笛梵个，并且接受这些测量带来的额外开销，这些开销应该被当成应用程序的一部分。
- 轻量级的性能剖析，比如为所有SQL语句计时，加上脚本总时间统计，流量趋于稳定可以采用随机采样
- New Relic会插入到应用程序中进行性能剖析，将收集到的数据发送到一个基于Web的仪表盘

### 3.2.1 测量PHP应用程序
- xhprof是Facebook开发给内部使用的，2009开源了，还有一些更底层的工具，xdebug、Valgrind和cachegrind
- 我们自己写的，IfP，不像xhprof一样对PHP做深入的测量，而是更关注数据库调用

## 3.3 剖析MySQL查询

### 3.3.1 剖析服务器负载
- 慢查询日志最初只是捕获比较”慢“的查询，而性能剖析缺需要针对所有的查询。5.1后可以通过设置long_query_time为0来捕获所有的查询，而且响应时间单位可以做到微妙级
- 在I/O密集场景做过测试，慢查询日志的开销可以忽略不计，更需要担心的是日志可能消耗大量的磁盘空间，最好不要长期开启慢查询日志，只在收集负载样本的期间开启即可
- 建议使用pt-query-digest分析慢查询日志，V/M提供了方差平均比，也就是常说的离差指数，高的查询对应的执行时间的变化较大，值得去优化

### 3.3.2 剖析单条查询
- SHOW PROFILE：默认是禁用的，可以通过服务器变量在会话（连接）级别动态地修改，SET profiling = 1; 然后，在服务器上执行的所有语句，都会测量其耗费的时间和其他一些查询执行状态变更相关的数据。SHOW PROFILE FOR QUERY 1; 可以给出查询执行的每个步骤及其花费的时间。
- SHOW STATUS：返回了一些计数器，既有服务器级别的全局计数器，也有机遇某个连接的会话级别的计数器。SHOW GLOBAL STATUS可以查看服务器级别的从服务器启动时开始计算的查询次数统计。FLUSH STATUS可以清0
- 慢查询日志：详细记录的条目包含了SHOW PROFILE和SHOW STATUS所有的输出，并且还有更多信息。
- Performance Schema：目前主要是用来测量当为提升服务器性能而修改MySQL源代码时使用，包括等待和互斥锁

### 3.3.3 使用性能剖析
- 好的剖析报告能够将潜在的问题显示出来，但最终的解决方案还需要用户来决定

### 3.4 诊断间歇性问题
- 间歇性的问题比如系统偶尔停顿或者慢查询，很难诊断

### 3.4.1 单条查询问题还是服务器问题
- 如果服务器上所有的程序都突然变慢，又突然变好，每一条查询也都变慢了，那么慢查询可能就不一定是原因，而是由于其他问题导致的结果。反过来说，如果服务器整体运行没有问题，只有某条查询偶尔变慢，就需要将注意力放到这条特定的慢查询上面。
- 使用SHOW GLOBAL STATUS：以较高频率比如一秒执行一次SHOW GLOBAL STATUS命令捕获数据，问题出现时，则可以通过某些计数器（比如Threads_running、Threads_connected、Questions和Queries）的“尖刺”或者“凹陷”来发现。
- 使用SHOW PROCESSLIST：通过不停的捕获SHOW PROCESSLIST的输出，来观察是否有大量线程处于不正常的状态或者有其他不正常的特征。例如查询很少长时间处于”statistics”状态，也很少会有大量线程报告当前连接用户是“未经验证的用户”
- 使用查询日志：long_query_time设置为0，注意找到吞吐量突然下降时间段的日志
- 理解发现的问题：利用上面的工具诊断时可能产生大量的输出结果，可以选择用gunplot或R，或者其他绘图工具将结果绘制成图形

### 3.4.2 捕获诊断数据
- 诊断触发器：误报是指收集了很多诊断数据，但期间其实没有发生问题。漏检则指在问题出现时没有捕获到数据。关键找到一些能和正常时的阈值进行比较的指标。通常情况下这是一个计数，比如正在运行的线程数量、处于”freeing items“状态的线程的数量等。选择一个合适的阈值。pt-stalk可以配置需要监控的变量、阈值、检查的频率等
- 需要收集什么样的数据：尽可能手机所有能收集的数据，但只在需要的时间段内收集。包括系统的状态、CPU利用率、磁盘使用率和可用空间、ps的输出采样、内存利用率，以及可以从MYSQL获得的信息，如SHOW STATUS、SHOW PROCESSLIST和SHOW INNODB STATUS。
- pt-collect收集信息，一般通过pt-stalk调用，系统中最好安装gdb和oprofile
- 根据两个目的来查看一些东西，第一，检查问题是否真的发生了。第二，是否有非常明显的跳跃性变化

### 3.4.3 一个诊断案例
- 使用pt-summary和pt-mysql-summary获取信息，这个例子中的服务器有16个CPU核心，12GB内存，数据量900MB，且全部采用InnoDB引擎，存储在一块SSD固态磁盘上，服务器的操作系统是GNU/Linux，MySQL版本5.1.37，InnoDB plugin 1.0.4
- 当一个资源变得效率低下时候：有可能的原因：资源被过度使用，余量已经不足以正常工作；资源没有被正确配置；资源已经损坏或者失灵。
- 我们来观察MySQL的I/O情况，通常来说，MySQL只会写数据、日志、排序文件和临时表到磁盘
- lsof命令观察服务器打开的文件句柄，发现问题之出，MySQL大约写了1.5GB的数据到临时表，这和SHOW PROCESSLIST有大量的Copying to tmp table温和。出现这种情况表名可能是缓存失效，当缓存条目全部失效，很多应用同时访问，就会出现这种情况。解决方案有两个，应用层面解决缓存失效或者避免使用磁盘临时表

### 3.5 其他剖析工具

### 3.5.1 使用USER_STATISTICS表
- 可以查找使用得最多或者使用得最少的表和索引，通过读取次数或者更新次数，或者两者一起排序
- 可以查找出从未使用的索引，可以考虑删除之
- 可以看看复制用户的CONNECTED_TIME和BUSY_TIME，以确认复制是否会很难跟上主库的进度

### 3.5.2 使用strace
- strace工具可以调查系统调用的情况

# 第4章 Schema与数据类型优化
- 良好的逻辑设计和物理设计是高性能的基石，应该根据系统将要执行的查询语句来设计schema，这往往需要权衡各种因素。

## 4.1 选择优化的数据类型
- 更小的通常更好：一般情况下，应该尽量选择使用可以正确存储数据的最小数据类型。但是要确保没有低估需要存储的值的范围。
- 简单就好，简单数据类型的操作通常需要更少的CPU周期。比如整型比字符操作代价更低，应该使用MySQL内建类型而不是字符串存储日期和时间，应该使用整型存储IP地址
- 尽量避免NULL，因为可为NULL的列使得索引、索引统计和值比较都更复杂。如果在列上建索引，就应该尽量避免设计成可为NULL的列

### 4.1.1 整数类型
- 有两种类型的数字，整数和实数
- 整数：TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT，分别8，16，34，32，64位存储空间
- MySQL可以为整数类型制定宽度，例如INT（11），对大多数应用这是没有意义的；存储和计算来说是相同的

### 4.1.2 实数类型
- 实数是带有小数部分的数字
- FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算，FLOAT4字节，DOUBLE8字节
- DECIMAL类型用于存储精确的小数
- DECIMAL（18，9）小数点两边个存储9个数字，一共使用9个字节：小数点钱的数字用4个字节，后用4个字节，小数点一个字节
- DECIMAL可以考虑用BIGINT代替，根据精确度乘以相应倍数

### 4.1.3 字符串类型
- VARCHAR类型用于存储可变长字符串，它比定长类型更节省空间，因为它仅使用必要的空间。需要使用1或2个额外字节记录字符串长度。如果列最大长度小于或者等于255字节，则使用1个，否则使用2个字节记录长度
- INNODB会把过长的VARCHAR存储为BLOB
- CHAR类型是定长的，适合存储很短的字符串。或者所有值都接近同一个长度，例如CHAR非常适合存储密码的MD5值。定长的CHAR不容易产生碎片。CHAR(1)存储Y和N的值比VARCHAR(1)好，VARCHAR(1)需要两个字节
- BINARY和VARBINARY，它们存储的是二进制字符串。存储的是字节码而不是字符。
- 慷慨是不明智的，VARCHAR(5)和VARCHAR(200)存储'hello'空间开销是一样，但更长的列会消耗更多的内存，利用内存临时表进行排序或者操作很糟糕，利用磁盘临时表也同样糟糕。所以最好的策略是指分配真正需要的空间
- BLOB和TEXT类型：分别采用二进制和字符方式存储，MySQL对BLOB和TEXT排序是对每个列的最前max_sort_length字节而不是整个字符串做排序。如果只需要排序前面一小部分字符串，可以用ORDER BY SUSTRING(column, length)
- 使用枚举（ENUM）代替字符串类型：枚举可以把一些不重复的字符串存储成一个预定义的集合，MySQL在内部会将每个值在列表中的位置保存为整数。当把列变成ENUM，关联变得很快，但VARCHAR和ENUM关联变慢

### 4.1.4 日期和时间类型
- DATETIME，能保存1001年到9999年，精度为秒，封装格式：YYYYMMDDHHMMSS整数，用8字节存储。默认显示："2008-01-16 22:37:08"
- TIMESTAMP，保存从1970-1-1午夜（格林尼治标准时间）以来的秒数，它和UNIX时间戳相同。用4个字节存储空间，只能表示从1970年-2038年。显示依赖时区。默认为NULL，默认插入则设置这个列为当前时间
- 尽量用TIMESTAMP，它比DATETIME空间效率更高。不推荐用时间戳存为整数值

### 4.1.5 位数据类型
- BIT：BIT(1)定义一个包含单个位的字段。MySQL把它当成字符串类型，而不是数字类型。不推荐用BIT，如果想在一个bit存储true/false，推荐CHAR(0)，保存空值（NULL)或者长度为0的字符串（空字符串）
- SET：如果需要存储很多true/false，可以考虑合并这些到一个SET数据结构。一种代替方案是用一个整数包装一系列的位。

### 4.1.6 选择标识符（identifier）
- MySQL在内部使用整数存储ENUM和SET类型，然后在做比较操作时转化为字符串
- 整数类型通常是标识列最好的选择，因为它们很快并且可以使用AUTO_INCREMENT
- 对于标识列来说，ENUM和SET类型通常是一个糟糕的选择
- 如果可能，应该避免使用字符串类型作为标识列，耗空间，比数字类型慢

### 4.1.7 特殊类型数据
- IPv4，通常用VARCHAR(15)来存储IP地址，但它实际上是32位无符号整数。MySQL提供INET_ATON()和INET_NTOA()函数来转换

## 4.2 MySQL schema 设计中的陷阱
- 太多的列：MySQL的存储引擎API工作时需要再服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后再服务器将缓冲内容解码成哥哥列。
- 太多的关联：如果希望查询执行得快速且并发性好，单个查询最好在12个表以内做关联
- 全能的枚举：防止过度使用枚举
- 变相的枚举：枚举允许在列中存储一组定义值中的单个值，集合列允许在列中存储一组定义值中的一个或多个值
- 非此发明（Not Invent Here）的NULL：处理NULL确实不容易，但有时候会比它替代方案好

## 4.3 范式和反范式
- 在范式化的数据库中，每个事实数据会出现并且只出现一次。相反，在反范式化的数据库中，信息是冗余的，可能会存储在多个地方。

### 4.3.1 范式的有点和缺点
- 范式化的更新通常比反范式要快
- 比较好的范式，只有很少或者没有重复数据，所以只需要修改更少的数据
- 范式化的表小，能更好的放入内存，执行操作会更快
- 很少的多余数据意味着检索列表数据更少的使用DISTINCT或者GROUP BY
- 唯一的缺点是需要关联，可能使一些索引策略无效

### 4.3.2 反范式的优点和缺点
- 因为在一张表里面，可以很好的避免关联
- 当数据比内存大时可能比关联快的多，避免了随机I/O
- 单独的表也能使用更有效的索引策略

### 4.3.3 混用范式化和反范式化
- 最常见的反范式化数据的方法是复制或缓存
- 另一个从父表冗余一些数据到字表的理由是排序的需要

## 4.4 缓存表和汇总表
- 缓存表拉来表示存储那些可以比较简单地从schema其他表获取（但是每次获取的速度比较慢）数据的表
- 汇总表，则保存的是使用GROUP BY语句聚合数据的表
- 当重建汇总表和缓存表时，通常需要保证数据在操作时依然可用。这就需要通过使用“影子表”来实现，”影子表“是一张在真实表”背后“创建的表。当完成创建后，可以通过一个原子的重命名切换影子表和原表。

### 4.4.1 物化视图
- Flexview提供很多不错的功能使得可以更简单地创建和维护物化视图

### 4.4.2 计数器表
- 记录网站点击次数，cnt
- 并发量大的时候可以考虑随机到槽，slot, cnt

### 4.5 加快ALTER TABLE操作速度
- ALTER TABLE MODIFY COLUMN不如ALTER TABLE ALTER COLUMN，后者可直接修改.frm文件而不涉及表数据，操作快

### 4.5.1 只修改.frm文件
- 创建一张相同结构的空表，并进行所需要的修改
- 执行FLUSH TABLES WITH READ LOCK，关闭所正在使用的表
- 交换.frm文件
- 执行UNLOCK TABLE释放读锁

### 4.5.2 快速创建MyISAM索引
- 先禁用索引，载入数据，然后重新启用索引

# 第5章 创建高性能的索引
- 索引是存储引擎用于快速找到记录的一种数据结构
- 索引优化应该是对查询性能优化最有效的手段了

## 5.1 索引基础
- 索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也非常重要。
### 5.1.1 索引的类型
- 索引是在存储引擎层而不是服务器层实现的

#### B-Tree索引
- 没有特别指明的时候，一般讨论的是B-Tree索引，使用B-Tree数据结构来存储数据。InnoDB底层使用的是B+Tree
- B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同
- 叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页
- 可以使用B-Tree索引的查询类型。B-Tree索引适用于全键值、键值范围或键前缀查找。例：key(last_name, first_name, dob)
  1. 全值匹配：全值匹配指的是和索引中的所有列进行匹配。
  2. 匹配最左前缀：查找所有姓为Allen的人，只使用索引的第一列
  3. 匹配列前缀：也可以只匹配某一列的值的开头部分。用于查找所以以J开头的姓的人，只使用索引的第一列
  4. 匹配范围值：查找姓在Allen和Barrymore之间的人。只使用了索引的第一列
  5. 精确匹配某一列并范围匹配另外一列：所有姓为Allen，并且名字以K开头的人。第一列last_name全匹配，第二列first_name范围匹配
  6. 只访问索引的查询：即查询只需要访问索引，而无需访问数据行。
- 因为索引树中的节点是有序的，所以除了按值查找，还支持ORDER BY操作（按顺序查找）
- B-Tree索引的限制
  1. 如果不是按照索引的最左列开始查找，则无法使用索引。无法查找名字为Bill的人，也无法查找某个特定的生日。
  2. 不能跳过索引中的列。无法查找姓为Smith并且某个特定日期出生的人
  3. 如果查询中某个列的范围查询，则其右边所有列无法使用索引优化查找。例如WHER last_name='Smith' AND first_name LIKE 'J%' AND dob = '1976-12-23'，这个查询只能使用索引的前两列。如果查询范围的值有限，可以通过多个等于条件来代替范围条件

#### 哈希索引
- 对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个比较小的值，并且不同键值的行计算出来 的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针
- 哈希索引的限制
  1. 哈希索引只包含哈希值和航指针，而不存储字段值，所以不能使用索引中的值避免读取行
  2. 哈希索引数据并不是按照索引值顺序存储的，无法进行排序
  3. 哈希索引也不支持部分索引列匹配查找
  4. 哈希索引只支持等值比较查询
  5. 访问哈希索引的数据非常快，除非有很多哈希冲突
  6. 如果哈希冲突很多的话，一些索引维护操作的代价也会很高
- InnoDB引擎有一个特殊的功能叫做”自适应哈希索引“。当InnoDB注意到某些索引值使用的非常频繁，它会在内存中基于B-Tree索引之上再创建一个哈希索引
- 创建自定义哈希索引，使用B-Tree查找，新加一列是哈希值。比如查找URL，URL很长，但哈希很短。可以使用CRC32做哈希

#### 空间数据索引（R-Tree）
- MyISAM表支持空间索引。对GIS解决方案做的比较好的是PostgreSQL的PostGIS

#### 全文索引
- 查找的是文本的关键词，而不是直接比较索引中的值。

#### 其他索引类型
- TokuDB使用形树索引。InnoDB还有聚簇索引，覆盖索引等

## 5.2 索引的优点
- 索引大大减少了服务器需要扫描的数据量
- 索引可以帮助服务器避免排序和临时表
- 索引可以将随机I/O变为顺序I/O

## 5.3 高性能的索引策略

### 5.3.1 独立的列
- ”独立的列“是指索引列不能是表达式的一部分，也不能是函数的参数。WHERE actor_id + 1 = 5; WHERE TO_DAYS(CURRENT_DATE)-TO_DAYS(date_col) <= 10;都不行。始终要将索引列单独放在比较符号的一侧

### 5.3.2 前缀索引和索引选择性
- 索引很长的列会让索引变大变慢，我们可以索引开始的部分字符。索引的选择性是指，不重复的索引值（也成为基数）和数据表的记录总数（#T）的比值，范围从1/#T到1之间，索引的选择性越高则查询率越高。
- 前缀的”基数“应该接近于完整列的”基数“
- 前缀索引是一种能使索引更小，更快的有效办法，缺点MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。
- 后缀索引，比如找到某个域名的所有电子邮件地址，把字符串反转后存储，并基于此建立前缀索引

### 5.3.3 多列索引
- 在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能
- 索引合并策略有时候是一种优化的结果，但也说明了索引建的很糟糕
  1. 当出现服务器对多个索引做相交操作（多个AND)，意味着需要一个包含所有相关列的多列索引
  2. 当服务器要对多个索引做联合操作时（多个OR），需要耗费大量CPU和内存资源在算法的缓存、排序和合并操作上
  3. 优化器不会把这些计算到”查询成本“中，不如改写为UNION的方式
- 如果在EXPLAIN中看到有索引合并，应该好好检查一下索引和表的结构，看是不是已经是最优的
