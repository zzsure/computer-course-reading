# 第1章 MySQL架构与历史

## 1.1 MySQL逻辑架构
- 最上层：连接处理、授权认证、安全等等
- 第二层：所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等
- 第三层：存储引擎，负责MySQL中数据存取和提取

### 1.1.1 连接管理与安全性
- 每个客户端连接都会在服务器进程中拥有一个线程
- 连接到MySQL服务器后，服务器需要进行认证。然后查询是否有特定权限

### 1.1.2 优化与执行
MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，一级选择合适的索引等

## 1.2 并发控制
无论何时，只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题

### 1.2.1 读写锁
读锁是共享的，相互不阻塞的。写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁

### 1.2.2 锁粒度
- 一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。
- 表锁：它会锁定整张表，一个用户对表进行写操作（插入、删除、更新等）前，需要先获得写锁。会阻塞其他用户对该表的所有的读写操作
- 行级锁：可以最大程度的支持并发处理（同时也带来了最大的锁开销），行级锁只在存储引擎层实现

## 1.3 事务
- 事务就是一组原子性的SQL查询，或者说一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败。
- ACID表示原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）

### 1.3.1 隔离级别
- READ UNCOMMITTED（未提交读）：事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读
- READ COMMITED（提交读）：一个事务开始时，只能”看见“已经提交的事务所做的修改。也叫不可重复读
- REPEATABLE READ（可重复读）：保证了在同一个事务中多次读取同样记录的结果是一致的。无法解决幻读（当某个事务在读取某个范围的记录时，会产生幻行）的问题
- SERIALIZABLE（可串行读）：强制事务串行执行，避免了幻读问题

### 1.3.2 死锁
- 死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用资源，从而导致恶性循环的现象。
- InnoDB目前处理死锁的方法是，将持有最少行级排他锁进行回滚
- 死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。

### 1.3.3 事务日志
使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把改修改行为记录到持久在硬盘的事务日志中，而不用每次都将修改的数据本身持久到磁盘。如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写会磁盘，此时系统崩溃，存储引擎在重启时能够将自动恢复这部分修改的数据。

### 1.3.4 MySQL中的事务

#### 自动提交
默认方式，如果不是显示地开始一个事务，则每个查询都被当做一个事务执行提交操作。

#### 在事务中混合使用存储引擎
事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。

#### 隐式和显示锁定
InnoDB采用的是两阶段锁定协议。在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻释放。前面描述的锁定都是隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁。

## 1.4 多版本并发控制
- MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC）
- MVCC的实现是通过保存数据在某个时间点的快照来实现的。也就说，不管需要执行多长时间，每个事务看到的数据都是一致的。
- InnoDB的MVCC，是通过再每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间。当然存储的并不是实际的时间值，而是系统版本号。
- MVCC只在REPEATABLE READ和READ COMMITTED两个级别下工作

## 1.5 MySQL的存储引擎
可以用SHOW TABLE STATUS命令显示表的相关信息

### 1.5.1 InnoDB存储引擎
InnoDB是MySQL的默认事务型引擎

#### InnoDB的历史
InnoDB是一个很重要的存储引擎，很多个人和公司都对其贡献代码，而不仅仅是Oracle公司的开发团队。一些重要的贡献者包括Google、Yasufumi Kinoshita、Percona、Facebook等

#### InnoDB概览
- InnoDB的数据存储在表空间中，采用MVCC来支持高并发，并且实现了四个标准的隔离级别。默认级别是可重复读，并且通过间隙锁防止幻读出现，间隙锁不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。
- InnoDB使用聚簇索引，对主键查询有很高的性能，不过它的二级索引中必须包含主键列，所以如果索引比较多的话，主键应当尽可能的小
- InnoDB支持真正的热备份

### 1.5.2 MyISAM存储引擎
MyISAM不支持事务和行级锁，崩溃后无法安全恢复

#### 存储
- MyISAM会存储到数据文件和索引文件两个表
- MyISAM表可存储行记录数

#### MyISAM特性

- 加锁与并发：MyISAM对整张表加锁，而不是针对行
- 修复：可以手工或者自动执行检查和修复操作
- 索引特性：支持全文索引，这是一种基于分词创建的索引
- 延迟更新索引键：DELAY_KEY_WRITE，修改执行完成后，索引先写到内存中键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引快写入到磁盘。

#### MyISAM压缩表
如果表再创建并导入数据以后，不会在进行修改操作，可用压缩表

#### MyISAM性能
设计简单，数据以紧密格式存储，某些场景下性能很好。典型的性能问题是表锁问题

### 1.5.3 MySQL内建的其他存储引擎
- Archive引擎：只支持INSERT和SELECT操作，利用zlib对插入的行进行压缩，SELECT查询需要执行权标扫描。Archive表适合日志和数据采集类应用
- Blackhole引擎：丢弃所有插入数据，不做任何保存。可以用于复制数据到备库
- CSV引擎：可将CSV文件作为MySQL的表来处理
- Federated引擎：是访问其他MySQL服务器的一个代理
- Memory引擎：需要快速访问数据，数据不会修改，重启丢失也没问题的话，可以使用。
- Merge引擎：多个MyISAM表合并而来的虚拟表
- NDB集群引擎：作为SQL和NDB原生协议之间的接口

### 1.5.4 第三方存储引擎
- OLTP类引擎：改进点主要集中在性能、可测量性和操作灵活性方面
- 面向列的存储引擎：如果不需要整行数据，面向列的方式可以传输更少的数据
- 社区存储引擎：Aria解决了崩溃安全恢复问题的MyISAM，Groonga全文索引引擎，OQGraph支持图操作，Q4M实现了队列操作，SphinxSE全文索引服务器提供了SQL接口，Spider实现了分片，VPForMySQL实现了垂直分区，可将表分成不同列的组合

### 1.5.5 选择合适的引擎
- 除非需要InnoDB不具备的特性，否则都优先选择InnoDB。选择引擎需要考虑事务、备份、崩溃恢复、特有的特征来选择
- 日志型应用：比如apache将网站所有访问信息记录到表，只是记录日志，对插入速度有很高要求，选择MyISAM或者Archive
- 只读或者大部分情况下只读的表：用于编制类目或者分列清单，不介意MyISAM的崩溃恢复问题可选MyISAM
- 订单处理：支持事务是必要选项，对外键支持，InnoDB是最佳选择
- 电子公告牌和主题讨论论坛：流量突增后，查询非常慢，选MyISAM
- CD-ROM应用：选择MyISAM或者MyISAM压缩表，这样表之间可以隔离，并且可以再不同介质上互相拷贝
- 大数据量：单机数据量在3~5TB，InnoDB运行的还不错。如果10TB以上，需要建立数据仓库，Infobright最成功的解决方案，有的可能适合TokuDB

### 1.5.6 转化表的引擎

#### ALTER TABLE
MySQL会按行将数据从原表复制到一张新的表中，在复制期间可能会消耗系统所有的I/O能力，同时原表会加上读锁。

#### 导出与导入
mysqldump导出数据到文件，然后修改文件中CREATE TABLE语句的存储引擎选项，然后再导入

#### 创建与查询（CREATE和SELECT）
不需要导出整个表的数据，而是先创建一个新的存储引擎的表，然后利用INSERT...SELECT语句来导数据

## 1.6 MySQL时间线（Timeline）
MySQL 55可以说是MySQL历史上质量最高的版本，采用了InnoDB plugin的版本在高并发的时候性能明显更好。

## 1.7 MySQL的开发模式
MySQL依然遵循GPL开发协议，全部的源代码（除了一些商用版本的插件）都会开放给社区

## 1.8 总结
MySQL拥有分层架构，上层是服务器层的服务和查询执行引擎，下层则是存储引擎。虽然有很多不同作用的插件API，但存储引擎的API还是最重要的。如果能理解MySQL在存储引擎和服务层之间处理查询时如何通过API来回交互，就能抓住MySQL的核心基础架构和精髓。

# 第2章 MySQL基准测试
基准测试是针对系统设计的一种压力测试，通常的目标是为了掌握系统的行为。但也有其他原因，如重现某个系统状态，或者是做新硬件的可靠性测试。

## 2.1 为什么需要基准测试
因为基准测试是唯一方便有效的、可以学习系统在给定的工作负载下会发生什么的方法。基准测试可以观察系统在不同压力下的行为，评估系统的容量，掌握哪些是重要变化，或者观察系统如何处理不同的数据。基准测试可以再系统使肌肤在之外创造一些虚构场景进行测试。

## 2.2 基准测试的策略
两种主要的策略：一个是针对系统的整体测试 另外是单独测试MySQL

### 2.2.1 测试何种指标
- 吞吐量：指的是单位时间内的事务处理数。
- 响应时间或者延迟：测试任务所需的整体时间
- 并发性：需要关注的是正在工作中的并发操作，或者是同时工作的线程数或者连接数。当并发增加时，需要测量吞吐量是否下降，响应时间是否变长。如果是这样，应用可能无法处理峰值压力。
- 可扩展性：给系统增加一倍的工作，在理想情况下就能获得两倍的结果

## 2.3 基准测试方法

### 2.3.1 设计和规划基准测试
首先要获得生产数据集的快照，并且该快照很容易还原，以便进行后续的测试

### 2.3.2 基准测试应该运行多长时间
进准侧四应该运行足够的时间。等系统看起来稳定的时间至少等于系统预热的时间。

### 2.3.3 获取系统性能和状态
需要记录的数据包括系统状态和性能指标，诸如CPU使用率、磁盘I/O、网络流量统计、SHOW GLOBAL STATUS计数器等。

### 2.3.4 获得准确的测试结果
确认测试结果是否可重复

### 2.3.5 运行基准测试并分析结果
尽可能地使所有测试过程自动化，包括装载数据、系统预热、执行测试、记录结果等

### 2.3.6 绘图的重要性
使用gnuplot绘制图形，图形可以找出性能尖刺。

## 2.4 基准测试工具
### 2.4.1 集成式测试工具
- ab：Apache HTTP服务器基准测试工具。它可以测试HTTP服务器每秒最多可以处理多少请求。
- http_load：可以通过一个输入文件提供多个URL，进行随机测试
- JMeter：虽然是设计测试Web应用的，但也可以用于测试其他诸如FTP服务器，或者通过JDBC进行数据库查询测试

### 2.4.2 单组件式测试工具
- mysqlslap：可以模拟服务器的负载，并输出计时信息
- MySQL Benchmark Suite(sql-bench)：主要用于测试服务器执行查询的速度
- Super Smack：用于MySQL和Post过热SQL的基准测试工具，可以提供压力测试和负载生成
- Database Test Suite：类似某些工业标准测试的测试工具集
- Percona's TPCC-MySQL Tool：类似TPC-C的基准测试工具集
- sysbench：一款多线程系统压测工具
- MySQL内置的BENCHMARK()函数，可以测试某些特定操作的执行速度

## 2.5 基准测试案例

### 2.5.1 http_load
- http_load -parallel 1 -seconds 10 urls.txt
- 模拟同时有5个并发用户：http_load -parallel 5 -seconds 10 urls.txt
- 模拟访问的请求率（比如每秒5次）来压力测试：http_load -rate 5 -seconds 10 urls.txt

### 2.5.2 MySQL基准测试套件
- MySQL Benchmark Suite，在MySQL安装目录的sql-bench子目录中包含该工具
- 运行全部测试：./run-all-tests --server=mysql --user=root --log --fast
- 只进行insert测试：./test-insert

### 2.5.3 sysbench
- sysbench可以执行多种类型的基准测试，不仅设计用来测试数据库的性能，也可以测试运行数据库的服务器的性能
- sysbench的CPU基准测试：计算素数直到某个最大值所需要的时间，sysbench --test=cpu --cpu-max-prime=20000 run
- sysbench的文件I/O基准测试，可以测试系统在不同I/O负载下的性能，对于比较不同的磁盘驱动器、不同的RAID卡、不同的RAID模式很有帮助。测试的数据要比内存大，sysbench --test=fileio --file-total-size=150G prepare来创建数据集，运行文件I/O混合随机读/写基准测试：sysbench --test=fileio --file-total-size=150G --file-test-mode=rndrw --init-rng=on --max-time=300 --max-requests=0 run，可看出每秒请求书和总吞吐量等。sysbench --test=fileio --file-total-size=150G cleanup清除测试文件。
- sysbench的OLTP基准测试：OLTP模拟了一个简单的失误处理系统的工作负载。测试后结果包含总的事务数，每秒事务数，时间统计信息，线程公平性统计信息
- sysbench其他特征，和数据库没关系。内存：测试内存的连续读写性能。线程：测试线程调度器的性能。互斥锁：测试互斥锁的性能。顺序写：测试顺序写的性能。

### 2.5.4 数据库测试套件中的dbt2 TPC-C测试
- TPC-C是TPC组织发布的一个测试规范，用于模拟测试复杂的在线事务处理系统（OLTP），它的测试结果包括每分钟事务数（tpmC），以及每事务的成本（Price/tpmC）

### 2.5.5 Percona的TPCC-MySQL测试工具
- sysbench的测试很简单，结果也具有可比性，但无法模拟真实业务的压力
- TPC-C测试能模拟真实压力，dbt2是TPC-C的一个很好实现，但没有得到TPC组织认可
- 本书作者开发了Percona，建立数据库和表结构、加载数据、执行测试

# 第3章 服务器性能剖析
- 最常碰到的三个性能相关的服务请求是：如何确认服务器是否达到了性能最佳的状态、找出某条语句为什么执行不够快，以及诊断被用户描述成“停顿”、“堆积”或者“卡死”的某些间歇性疑难故障

## 3.1 性能优化简介
- 我们将性能定义为完成某件任务所需要的时间度量，换句话说，性能就是响应时间
- 假设性能优化就是再一定的工作负载下尽可能地降低响应时间
- 很多人在优化时，都将精力放在修改一些东西上，缺很少去进行精确的测量，我们的做法完全相反，将花费非常多，甚至90%的时间来测量响应时间花哪里，然后对症下药
- 有两种比较常见的情况导致不合适的测量，在错误的时间启动和停止测量。测量的是聚合后的信息，而不是目标活动本身

### 3.1.1 通过性能剖析进行优化
- 性能剖析一般有两个步骤：测试任务所花费的时间；然后对结果进行统计和排序，将重要的任务排在前面
- 基于执行时间的分析研究的是什么任务的执行时间最长，而基于等待的分析是判断任务在什么地方被阻塞的时间最长

### 3.1.2 理解性能剖析
- 值得优化的查询：一些只占总相应时间比重很小的查询是不值得优化的
- 异常情况：某些任务即使没有出现在性能剖析输出的前面也需要优化，比如某些任务执行次数很少，但每次执行都非常慢，严重影响用户体验
- 未知的未知：丢失的时间是指任务的总时间和实际测量到的时间之间的差
- 被掩藏的细节：无法显示所有相应时间的分布，只相信平均值是非常危险的。医院所有病人的平均体温是没有任何价值的

## 3.2 对应用程序进行性能剖析
- 建议在所有的项目中都考虑包含性能剖析的代码。往已有的项目中加入性能剖析代码也许很困难，新项目就简单一些。
- 大多数设计和构建过高性能应用程序的人相信，应该尽可能地测量一切可以测量的笛梵个，并且接受这些测量带来的额外开销，这些开销应该被当成应用程序的一部分。
- 轻量级的性能剖析，比如为所有SQL语句计时，加上脚本总时间统计，流量趋于稳定可以采用随机采样
- New Relic会插入到应用程序中进行性能剖析，将收集到的数据发送到一个基于Web的仪表盘

### 3.2.1 测量PHP应用程序
- xhprof是Facebook开发给内部使用的，2009开源了，还有一些更底层的工具，xdebug、Valgrind和cachegrind
- 我们自己写的，IfP，不像xhprof一样对PHP做深入的测量，而是更关注数据库调用

## 3.3 剖析MySQL查询

### 3.3.1 剖析服务器负载
- 慢查询日志最初只是捕获比较”慢“的查询，而性能剖析缺需要针对所有的查询。5.1后可以通过设置long_query_time为0来捕获所有的查询，而且响应时间单位可以做到微妙级
- 在I/O密集场景做过测试，慢查询日志的开销可以忽略不计，更需要担心的是日志可能消耗大量的磁盘空间，最好不要长期开启慢查询日志，只在收集负载样本的期间开启即可
- 建议使用pt-query-digest分析慢查询日志，V/M提供了方差平均比，也就是常说的离差指数，高的查询对应的执行时间的变化较大，值得去优化

### 3.3.2 剖析单条查询
- SHOW PROFILE：默认是禁用的，可以通过服务器变量在会话（连接）级别动态地修改，SET profiling = 1; 然后，在服务器上执行的所有语句，都会测量其耗费的时间和其他一些查询执行状态变更相关的数据。SHOW PROFILE FOR QUERY 1; 可以给出查询执行的每个步骤及其花费的时间。
- SHOW STATUS：返回了一些计数器，既有服务器级别的全局计数器，也有机遇某个连接的会话级别的计数器。SHOW GLOBAL STATUS可以查看服务器级别的从服务器启动时开始计算的查询次数统计。FLUSH STATUS可以清0
- 慢查询日志：详细记录的条目包含了SHOW PROFILE和SHOW STATUS所有的输出，并且还有更多信息。
- Performance Schema：目前主要是用来测量当为提升服务器性能而修改MySQL源代码时使用，包括等待和互斥锁
