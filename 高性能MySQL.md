# 第1章 MySQL架构与历史

## 1.1 MySQL逻辑架构
- 最上层：连接处理、授权认证、安全等等
- 第二层：所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等
- 第三层：存储引擎，负责MySQL中数据存取和提取

### 1.1.1 连接管理与安全性
- 每个客户端连接都会在服务器进程中拥有一个线程
- 连接到MySQL服务器后，服务器需要进行认证。然后查询是否有特定权限

### 1.1.2 优化与执行
MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，一级选择合适的索引等

## 1.2 并发控制
无论何时，只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题

### 1.2.1 读写锁
读锁是共享的，相互不阻塞的。写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁

### 1.2.2 锁粒度
- 一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。
- 表锁：它会锁定整张表，一个用户对表进行写操作（插入、删除、更新等）前，需要先获得写锁。会阻塞其他用户对该表的所有的读写操作
- 行级锁：可以最大程度的支持并发处理（同时也带来了最大的锁开销），行级锁只在存储引擎层实现

## 1.3 事务
- 事务就是一组原子性的SQL查询，或者说一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败。
- ACID表示原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）

### 1.3.1 隔离级别
- READ UNCOMMITTED（未提交读）：事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读
- READ COMMITED（提交读）：一个事务开始时，只能”看见“已经提交的事务所做的修改。也叫不可重复读
- REPEATABLE READ（可重复读）：保证了在同一个事务中多次读取同样记录的结果是一致的。无法解决幻读（当某个事务在读取某个范围的记录时，会产生幻行）的问题
- SERIALIZABLE（可串行读）：强制事务串行执行，避免了幻读问题

### 1.3.2 死锁
- 死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用资源，从而导致恶性循环的现象。
- InnoDB目前处理死锁的方法是，将持有最少行级排他锁进行回滚
- 死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。

### 1.3.3 事务日志
使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把改修改行为记录到持久在硬盘的事务日志中，而不用每次都将修改的数据本身持久到磁盘。如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写会磁盘，此时系统崩溃，存储引擎在重启时能够将自动恢复这部分修改的数据。

### 1.3.4 MySQL中的事务

#### 自动提交
默认方式，如果不是显示地开始一个事务，则每个查询都被当做一个事务执行提交操作。

#### 在事务中混合使用存储引擎
事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。

#### 隐式和显示锁定
InnoDB采用的是两阶段锁定协议。在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻释放。前面描述的锁定都是隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁。

## 1.4 多版本并发控制
- MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC）
- MVCC的实现是通过保存数据在某个时间点的快照来实现的。也就说，不管需要执行多长时间，每个事务看到的数据都是一致的。
- InnoDB的MVCC，是通过再每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间。当然存储的并不是实际的时间值，而是系统版本号。
- MVCC只在REPEATABLE READ和READ COMMITTED两个级别下工作

## 1.5 MySQL的存储引擎
可以用SHOW TABLE STATUS命令显示表的相关信息

### 1.5.1 InnoDB存储引擎
InnoDB是MySQL的默认事务型引擎

#### InnoDB的历史
InnoDB是一个很重要的存储引擎，很多个人和公司都对其贡献代码，而不仅仅是Oracle公司的开发团队。一些重要的贡献者包括Google、Yasufumi Kinoshita、Percona、Facebook等

#### InnoDB概览
- InnoDB的数据存储在表空间中，采用MVCC来支持高并发，并且实现了四个标准的隔离级别。默认级别是可重复读，并且通过间隙锁防止幻读出现，间隙锁不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。
- InnoDB使用聚簇索引，对主键查询有很高的性能，不过它的二级索引中必须包含主键列，所以如果索引比较多的话，主键应当尽可能的小
- InnoDB支持真正的热备份

### 1.5.2 MyISAM存储引擎
MyISAM不支持事务和行级锁，崩溃后无法安全恢复

#### 存储
- MyISAM会存储到数据文件和索引文件两个表
- MyISAM表可存储行记录数

#### MyISAM特性

- 加锁与并发：MyISAM对整张表加锁，而不是针对行
- 修复：可以手工或者自动执行检查和修复操作
- 索引特性：支持全文索引，这是一种基于分词创建的索引
- 延迟更新索引键：DELAY_KEY_WRITE，修改执行完成后，索引先写到内存中键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引快写入到磁盘。

#### MyISAM压缩表
如果表再创建并导入数据以后，不会在进行修改操作，可用压缩表

#### MyISAM性能
设计简单，数据以紧密格式存储，某些场景下性能很好。典型的性能问题是表锁问题

### 1.5.3 MySQL内建的其他存储引擎
- Archive引擎：只支持INSERT和SELECT操作，利用zlib对插入的行进行压缩，SELECT查询需要执行权标扫描。Archive表适合日志和数据采集类应用
- Blackhole引擎：丢弃所有插入数据，不做任何保存。可以用于复制数据到备库
- CSV引擎：可将CSV文件作为MySQL的表来处理
- Federated引擎：是访问其他MySQL服务器的一个代理
- Memory引擎：需要快速访问数据，数据不会修改，重启丢失也没问题的话，可以使用。
- Merge引擎：多个MyISAM表合并而来的虚拟表
- NDB集群引擎：作为SQL和NDB原生协议之间的接口

### 1.5.4 第三方存储引擎
- OLTP类引擎：改进点主要集中在性能、可测量性和操作灵活性方面
- 面向列的存储引擎：如果不需要整行数据，面向列的方式可以传输更少的数据
- 社区存储引擎：Aria解决了崩溃安全恢复问题的MyISAM，Groonga全文索引引擎，OQGraph支持图操作，Q4M实现了队列操作，SphinxSE全文索引服务器提供了SQL接口，Spider实现了分片，VPForMySQL实现了垂直分区，可将表分成不同列的组合

### 1.5.5 选择合适的引擎
- 除非需要InnoDB不具备的特性，否则都优先选择InnoDB。选择引擎需要考虑事务、备份、崩溃恢复、特有的特征来选择
- 日志型应用：比如apache将网站所有访问信息记录到表，只是记录日志，对插入速度有很高要求，选择MyISAM或者Archive
- 只读或者大部分情况下只读的表：用于编制类目或者分列清单，不介意MyISAM的崩溃恢复问题可选MyISAM
- 订单处理：支持事务是必要选项，对外键支持，InnoDB是最佳选择
- 电子公告牌和主题讨论论坛：流量突增后，查询非常慢，选MyISAM
- CD-ROM应用：选择MyISAM或者MyISAM压缩表，这样表之间可以隔离，并且可以再不同介质上互相拷贝
- 大数据量：单机数据量在3~5TB，InnoDB运行的还不错。如果10TB以上，需要建立数据仓库，Infobright最成功的解决方案，有的可能适合TokuDB

### 1.5.6 转化表的引擎

#### ALTER TABLE
MySQL会按行将数据从原表复制到一张新的表中，在复制期间可能会消耗系统所有的I/O能力，同时原表会加上读锁。

#### 导出与导入
mysqldump导出数据到文件，然后修改文件中CREATE TABLE语句的存储引擎选项，然后再导入

#### 创建与查询（CREATE和SELECT）
不需要导出整个表的数据，而是先创建一个新的存储引擎的表，然后利用INSERT...SELECT语句来导数据

## 1.6 MySQL时间线（Timeline）
MySQL 55可以说是MySQL历史上质量最高的版本，采用了InnoDB plugin的版本在高并发的时候性能明显更好。

## 1.7 MySQL的开发模式
MySQL依然遵循GPL开发协议，全部的源代码（除了一些商用版本的插件）都会开放给社区

## 1.8 总结
MySQL拥有分层架构，上层是服务器层的服务和查询执行引擎，下层则是存储引擎。虽然有很多不同作用的插件API，但存储引擎的API还是最重要的。如果能理解MySQL在存储引擎和服务层之间处理查询时如何通过API来回交互，就能抓住MySQL的核心基础架构和精髓。

# 第2章 MySQL基准测试
基准测试是针对系统设计的一种压力测试，通常的目标是为了掌握系统的行为。但也有其他原因，如重现某个系统状态，或者是做新硬件的可靠性测试。

## 2.1 为什么需要基准测试
因为基准测试是唯一方便有效的、可以学习系统在给定的工作负载下会发生什么的方法。基准测试可以观察系统在不同压力下的行为，评估系统的容量，掌握哪些是重要变化，或者观察系统如何处理不同的数据。基准测试可以再系统使肌肤在之外创造一些虚构场景进行测试。

## 2.2 基准测试的策略
两种主要的策略：一个是针对系统的整体测试 另外是单独测试MySQL

### 2.2.1 测试何种指标
- 吞吐量：指的是单位时间内的事务处理数。
- 响应时间或者延迟：测试任务所需的整体时间
- 并发性：需要关注的是正在工作中的并发操作，或者是同时工作的线程数或者连接数。当并发增加时，需要测量吞吐量是否下降，响应时间是否变长。如果是这样，应用可能无法处理峰值压力。
- 可扩展性：给系统增加一倍的工作，在理想情况下就能获得两倍的结果

## 2.3 基准测试方法

### 2.3.1 设计和规划基准测试
首先要获得生产数据集的快照，并且该快照很容易还原，以便进行后续的测试

### 2.3.2 基准测试应该运行多长时间
进准侧四应该运行足够的时间。等系统看起来稳定的时间至少等于系统预热的时间。

### 2.3.3 获取系统性能和状态
需要记录的数据包括系统状态和性能指标，诸如CPU使用率、磁盘I/O、网络流量统计、SHOW GLOBAL STATUS计数器等。

### 2.3.4 获得准确的测试结果
确认测试结果是否可重复

### 2.3.5 运行基准测试并分析结果
尽可能地使所有测试过程自动化，包括装载数据、系统预热、执行测试、记录结果等

### 2.3.6 绘图的重要性
使用gnuplot绘制图形，图形可以找出性能尖刺。

## 2.4 基准测试工具
### 2.4.1 集成式测试工具
- ab：Apache HTTP服务器基准测试工具。它可以测试HTTP服务器每秒最多可以处理多少请求。
- http_load：可以通过一个输入文件提供多个URL，进行随机测试
- JMeter：虽然是设计测试Web应用的，但也可以用于测试其他诸如FTP服务器，或者通过JDBC进行数据库查询测试

### 2.4.2 单组件式测试工具
- mysqlslap：可以模拟服务器的负载，并输出计时信息
- MySQL Benchmark Suite(sql-bench)：主要用于测试服务器执行查询的速度
- Super Smack：用于MySQL和Post过热SQL的基准测试工具，可以提供压力测试和负载生成
- Database Test Suite：类似某些工业标准测试的测试工具集
- Percona's TPCC-MySQL Tool：类似TPC-C的基准测试工具集
- sysbench：一款多线程系统压测工具
- MySQL内置的BENCHMARK()函数，可以测试某些特定操作的执行速度

## 2.5 基准测试案例

### 2.5.1 http_load
- http_load -parallel 1 -seconds 10 urls.txt
- 模拟同时有5个并发用户：http_load -parallel 5 -seconds 10 urls.txt
- 模拟访问的请求率（比如每秒5次）来压力测试：http_load -rate 5 -seconds 10 urls.txt

### 2.5.2 MySQL基准测试套件
- MySQL Benchmark Suite，在MySQL安装目录的sql-bench子目录中包含该工具
- 运行全部测试：./run-all-tests --server=mysql --user=root --log --fast
- 只进行insert测试：./test-insert

### 2.5.3 sysbench
- sysbench可以执行多种类型的基准测试，不仅设计用来测试数据库的性能，也可以测试运行数据库的服务器的性能
- sysbench的CPU基准测试：计算素数直到某个最大值所需要的时间，sysbench --test=cpu --cpu-max-prime=20000 run
- sysbench的文件I/O基准测试，可以测试系统在不同I/O负载下的性能，对于比较不同的磁盘驱动器、不同的RAID卡、不同的RAID模式很有帮助。测试的数据要比内存大，sysbench --test=fileio --file-total-size=150G prepare来创建数据集，运行文件I/O混合随机读/写基准测试：sysbench --test=fileio --file-total-size=150G --file-test-mode=rndrw --init-rng=on --max-time=300 --max-requests=0 run，可看出每秒请求书和总吞吐量等。sysbench --test=fileio --file-total-size=150G cleanup清除测试文件。
