# 前言
模块需要实现一个“共同关注”功能，用于计算两个用户关注了哪些共同的用户。关系数据库不能很好的支持，Redis的集合可以执行交集、并集、差集等操作

# 第1章 引言
如果想打算深入了解Redis实现原理的底层细节，本书在RedisBook.com提供了一份带有详细注释的Redis源码

## 1.1 Redis版本说明
本书是基于Redis 2.9 — 也即是Redis 3.0的开发版来编写的

## 1.2 章节安排

### 第一部分 ”数据结构与对象“
- 数据库键总是一个字符串对象
- 而数据库键值则可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象

### 第二部分 ”单机数据库的实现“
- 第9章 ”数据库“对Redis数据库的实现原理进行了介绍
- 第10章”RDB持久化“和第11章”AOF持久化“分别介绍了Redis两种不同的持久化方法的实现原理
- 第12章“事件”对Redis的文件事件和时间事件进行了介绍
- 第13章“客户端”对Redis服务器维护和管理客户端状态的方法进行了介绍
- 第14章“服务器”对单机Redis服务器的运行机制进行了介绍

### 第三部分 “多机数据库的实现”
- 第15章”复制"对Redis的主从复制功能的实现原理进行了介绍
- 第16章“Sentinel”对Redis Sentinel的实现原理进行了介绍
- 第17章“集群”对Redis集群的实现原理进行了介绍

### 第四部分 ”独立功能的实现“
- 第18章“发布与订阅”对PUBLISH、SUBSCRIBE、PUBSUB等命令的实现原理进行了介绍
- 第19章“事务”对MULTI、EXEC、WATCH等命令的实现原理进行了介绍
- 第20章“Lua脚本”对EVAL、EVALSHA、SCRIPT LOAD等命令的原理进行了介绍
- 第21章“排序”对SORT命令以及SORT命令所有可用选项的实现原理进行了介绍
- 第22章”二进制位数组“对Redis保存二进制位数组的方法进行了介绍
- 第23章”慢查询日志"对Redis创建和保存慢查询日志的方法进行了介绍
- 第24章“监视器”介绍了将客户端变为监视器的方法

## 1.3 推荐的阅读方法
第一部分和第二部分必读，第三部分是多机版应用部分，第四部分包含的各章是完全独立的

## 1.4 杭温规则
- 引用Redis源代码文件file中的名字name时，file/name
- 引用标准头文件file中的名字name，使用<file>/name
- 第一次引用某个名字之后，本书就会去掉名字前缀的文件名
- 本书使用struct.property格式来引用struct结构的porperty属性

## 1.5配套网站
redisbook.com记录了本书的最新消息，并且提供了附带详细注释的Redis源代码

# 第2章 简单动态字符串
- Redis没有用C字符串（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串（simple dynamic string, SDS）的抽象类型
- 客户端执行SET msg "hello world"，那么Redis将创建一个键值对，键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串"msg"的SDS，键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串"hello world"的SDS
- 客户端执行RPUSH fruits "apple" "banana" "cherry"，Redis将在数据库创建一个新的键值对，键值对的键是一个字符串对象，底层实现了一个保存字符串"fruits"的SDS，键值对的值是一个列表对象，列表对象的三个值分别由3个SDS实现
- SDS还用于AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区

## 2.1 SDS的定义
sdshdr的len记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度，free记录buf数组中未使用字节的数量，字节数组，用于保存字符串

## 2.2 SDS与C字符串的区别
C语言使用长度N+1的字符串来标识长度为N的字符串，字符串数组的最后一个元素总是空字符串'\0'

### 2.2.1 常数复杂度获取字符串长度
C语言字符串获取数组需要遍历，时间复杂度O(N)，Redis是O(1)

### 2.2.2 杜绝缓冲区溢出
因为C语言不记录自身长度，strcat假定dest会有足够多的内存，如果假定不成立，就会产生缓冲区溢出。Redis里面的sdscat检查空间不足，会先扩展空间，然后再执行拼接操作。

### 2.2.3 减少修改字符串时带来的内存重分配次数
C字符串如果append，需要重新分配内存，如果忘记则可能会产生缓冲区溢出。如果缩短字符串trim，需要释放字符串不使用的内存空间，否则会产生内存泄露。Redis通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略

### 2.2.4 二进制安全
C字符串中的字符必须符合某种编码（比如ASCII)，并且除了字符串的末位之外，字符串里面不能包含空字符串，否则最先被程序读入的空字符串将被认为是字符串结尾。SDS的API都是二进制安全的

### 2.2.5 兼容部分C字符串函数
Redis会重用C语言的函数

# 第3章 链表
除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，保存多个客户端状态信息，以及使用链表来构建客户端输出缓冲区

## 3.1 链表和链表节点的实现
- 每个链表节点使用一个adlist.h/listNode结构来表示，前置节点，后置节点，节点的值
- adlist.h/list来持有链表，包含了头指针head、表尾指针tail，以及链表长度计数器len，dup函数复制链表节点锁保存的值，free函数用于释放链表节点所保存的值，match对比链表节点所保存的值和另一个输入值是否相等。
- Redis的链表特征：双端，无环，带表头指针和表尾指针，带表长度计数器，多态

## 3.2 链表和链表节点的API
- listSetDupMethod，将给定的函数设置为链表的节点值复制函数
- listGetDupMethod：返回链表当前正在使用的节点值复制函数
...

# 第4章 字典
- 字典，又称符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构
- 键和值称为键值对
- 字典中的每个键都是独一无二的
- Redis数据库就是用字典作为底层实现的，字典还是哈希键的底层实现之一

## 4.1 字典的实现
Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对

### 4.1.1 哈希表
哈希表由dict.h/dictht结构定义

### 4.1.2 哈希表节点
哈希表节点使用dictEntry结构表示，每个dictEntry都保存着一个键值对。

### 4.1.3 字典
Redis中的字典由dict.h/dict结构表示，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。

## 4.2 哈希算法
当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

## 4.3 解决键冲突
当两个或以上数量的键被分配到了哈希数组的同一个索引上面时，我们称这些键发生了冲突。Redis哈希表使用链地址法来解决键冲突。next指针构成单向链表，因为没有尾指针，所以新元素总是插入到表头的位置

## 4.4 rehash
当哈希表保存的键值对数量太多或者太少时，程序需要rehash（重新散列），rehash的步骤
1. 为ht[1]分配空间，扩展的话ht[1]为第一个大于等于ht[0].used*2的2的n次方，收缩ht[1]的大小为第一个大于等于ht[0].used的2的n次方
2. 将保存在ht[0]的所有键值对rehash到ht[1]上面，重新计算键的哈希值和索引值
3. 当所有ht[0]已迁移到ht[1]，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表

哈希表的扩展与收缩
满足任意一个条件，程序会对哈希表进行扩展操作：
1. 服务器目前没有执行BGSAVE命令或者BGREWRITEAOF命令，哈希表负载因子大于等于1
2. 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，哈希表负载因子大于等于5

哈希表负载因子=ht[0].used/ht[0].size

当哈希表负载因子小于0.1，程序进行收缩操作
