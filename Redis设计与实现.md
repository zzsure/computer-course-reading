# 前言
模块需要实现一个“共同关注”功能，用于计算两个用户关注了哪些共同的用户。关系数据库不能很好的支持，Redis的集合可以执行交集、并集、差集等操作

# 第1章 引言
如果想打算深入了解Redis实现原理的底层细节，本书在RedisBook.com提供了一份带有详细注释的Redis源码

## 1.1 Redis版本说明
本书是基于Redis 2.9 — 也即是Redis 3.0的开发版来编写的

## 1.2 章节安排

### 第一部分 ”数据结构与对象“
- 数据库键总是一个字符串对象
- 而数据库键值则可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象

### 第二部分 ”单机数据库的实现“
- 第9章 ”数据库“对Redis数据库的实现原理进行了介绍
- 第10章”RDB持久化“和第11章”AOF持久化“分别介绍了Redis两种不同的持久化方法的实现原理
- 第12章“事件”对Redis的文件事件和时间事件进行了介绍
- 第13章“客户端”对Redis服务器维护和管理客户端状态的方法进行了介绍
- 第14章“服务器”对单机Redis服务器的运行机制进行了介绍

### 第三部分 “多机数据库的实现”
- 第15章”复制"对Redis的主从复制功能的实现原理进行了介绍
- 第16章“Sentinel”对Redis Sentinel的实现原理进行了介绍
- 第17章“集群”对Redis集群的实现原理进行了介绍

### 第四部分 ”独立功能的实现“
- 第18章“发布与订阅”对PUBLISH、SUBSCRIBE、PUBSUB等命令的实现原理进行了介绍
- 第19章“事务”对MULTI、EXEC、WATCH等命令的实现原理进行了介绍
- 第20章“Lua脚本”对EVAL、EVALSHA、SCRIPT LOAD等命令的原理进行了介绍
- 第21章“排序”对SORT命令以及SORT命令所有可用选项的实现原理进行了介绍
- 第22章”二进制位数组“对Redis保存二进制位数组的方法进行了介绍
- 第23章”慢查询日志"对Redis创建和保存慢查询日志的方法进行了介绍
- 第24章“监视器”介绍了将客户端变为监视器的方法

## 1.3 推荐的阅读方法
第一部分和第二部分必读，第三部分是多机版应用部分，第四部分包含的各章是完全独立的

## 1.4 杭温规则
- 引用Redis源代码文件file中的名字name时，file/name
- 引用标准头文件file中的名字name，使用<file>/name
- 第一次引用某个名字之后，本书就会去掉名字前缀的文件名
- 本书使用struct.property格式来引用struct结构的porperty属性

## 1.5配套网站
redisbook.com记录了本书的最新消息，并且提供了附带详细注释的Redis源代码

# 第2章 简单动态字符串
- Redis没有用C字符串（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串（simple dynamic string, SDS）的抽象类型
- 客户端执行SET msg "hello world"，那么Redis将创建一个键值对，键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串"msg"的SDS，键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串"hello world"的SDS
- 客户端执行RPUSH fruits "apple" "banana" "cherry"，Redis将在数据库创建一个新的键值对，键值对的键是一个字符串对象，底层实现了一个保存字符串"fruits"的SDS，键值对的值是一个列表对象，列表对象的三个值分别由3个SDS实现
- SDS还用于AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区

## 2.1 SDS的定义
sdshdr的len记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度，free记录buf数组中未使用字节的数量，字节数组，用于保存字符串

## 2.2 SDS与C字符串的区别
C语言使用长度N+1的字符串来标识长度为N的字符串，字符串数组的最后一个元素总是空字符串'\0'

### 2.2.1 常数复杂度获取字符串长度
C语言字符串获取数组需要遍历，时间复杂度O(N)，Redis是O(1)

### 2.2.2 杜绝缓冲区溢出
因为C语言不记录自身长度，strcat假定dest会有足够多的内存，如果假定不成立，就会产生缓冲区溢出。Redis里面的sdscat检查空间不足，会先扩展空间，然后再执行拼接操作。

### 2.2.3 减少修改字符串时带来的内存重分配次数
C字符串如果append，需要重新分配内存，如果忘记则可能会产生缓冲区溢出。如果缩短字符串trim，需要释放字符串不使用的内存空间，否则会产生内存泄露。Redis通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略

### 2.2.4 二进制安全
C字符串中的字符必须符合某种编码（比如ASCII)，并且除了字符串的末位之外，字符串里面不能包含空字符串，否则最先被程序读入的空字符串将被认为是字符串结尾。SDS的API都是二进制安全的

### 2.2.5 兼容部分C字符串函数
Redis会重用C语言的函数

# 第3章 链表
除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，保存多个客户端状态信息，以及使用链表来构建客户端输出缓冲区

## 3.1 链表和链表节点的实现
- 每个链表节点使用一个adlist.h/listNode结构来表示，前置节点，后置节点，节点的值
- adlist.h/list来持有链表，包含了头指针head、表尾指针tail，以及链表长度计数器len，dup函数复制链表节点锁保存的值，free函数用于释放链表节点所保存的值，match对比链表节点所保存的值和另一个输入值是否相等。
- Redis的链表特征：双端，无环，带表头指针和表尾指针，带表长度计数器，多态

## 3.2 链表和链表节点的API
- listSetDupMethod，将给定的函数设置为链表的节点值复制函数
- listGetDupMethod：返回链表当前正在使用的节点值复制函数
...

# 第4章 字典
- 字典，又称符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构
- 键和值称为键值对
- 字典中的每个键都是独一无二的
- Redis数据库就是用字典作为底层实现的，字典还是哈希键的底层实现之一

## 4.1 字典的实现
Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对

### 4.1.1 哈希表
哈希表由dict.h/dictht结构定义

### 4.1.2 哈希表节点
哈希表节点使用dictEntry结构表示，每个dictEntry都保存着一个键值对。

### 4.1.3 字典
Redis中的字典由dict.h/dict结构表示，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。

## 4.2 哈希算法
当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

## 4.3 解决键冲突
当两个或以上数量的键被分配到了哈希数组的同一个索引上面时，我们称这些键发生了冲突。Redis哈希表使用链地址法来解决键冲突。next指针构成单向链表，因为没有尾指针，所以新元素总是插入到表头的位置

## 4.4 rehash
当哈希表保存的键值对数量太多或者太少时，程序需要rehash（重新散列），rehash的步骤
1. 为ht[1]分配空间，扩展的话ht[1]为第一个大于等于ht[0].used*2的2的n次方，收缩ht[1]的大小为第一个大于等于ht[0].used的2的n次方
2. 将保存在ht[0]的所有键值对rehash到ht[1]上面，重新计算键的哈希值和索引值
3. 当所有ht[0]已迁移到ht[1]，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表

哈希表的扩展与收缩
满足任意一个条件，程序会对哈希表进行扩展操作：
1. 服务器目前没有执行BGSAVE命令或者BGREWRITEAOF命令，哈希表负载因子大于等于1
2. 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，哈希表负载因子大于等于5

哈希表负载因子=ht[0].used/ht[0].size

当哈希表负载因子小于0.1，程序进行收缩操作

# 第5章 跳跃表
- 跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点指针，从而达到快速访问节点的目的。
- Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员(member)是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。
- Redis只有在两个地方用到跳跃表，一个是实现有序集合键，两一个是在集群节点中用作内部数据结构

## 5.1 跳跃表的实现
- 跳跃表由redis.h/zskiplistNode表示跳跃列表节点和redis.h/zskiplist保存跳跃表节点的相关信息，比如节点数量，以及指向表头节点和表尾节点指针等
- ziplist结构：header表头，tail表尾，level层数最大的那个节点层数，length节点数量
- zskiplistNode结构：level层，层带有前进指针和跨度，backward后退指针，score分值，obj成员对象

# 第6章 整数集合
整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。

## 6.1 整数集合的实现
- intset.h/intset标识一个数据集合，contents是数组集合的底层实现：整数集合的每个元素都是contents数组的一个数据项，各个项在数组中按照值的大小从小到大有序地排列，并且数组不包含任何重复项
- length记录了整数集合包含的元素数量，也是contents数组的长度
- contents数组真正的类型取决于encoding属性的值

## 6.2 升级
升级集合并添加新元素首先根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。将底层数组现有所有元素转化成新元素相同类型，并将类型转化后的元素放置到正确位置上。将新元素添加到底层数组里面

## 6.3 升级的好处
一个是提升整数集合的灵活性，另一个是尽可能地节约内存

### 6.3.1 提升灵活性
C语言只能添加对应类型到数组里面，Redis的集合整数不用担心出现类型错误

### 6.3.2 节约内存
如果我们一直向整数集合添加int16_t，集合的底层就会一直是int16_t类型整数

## 6.4 降级
集合整数不支持降级操作

# 第7章 压缩列表
压缩列表（ziplist）是列表键和哈希键的底层实现之一。列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串。

## 7.1 压缩列表的构成
- 压缩列表是为了节约内存而开发的，由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值
- zlbytes记录整个压缩列表占用的内存字节数，zltail记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，zllen记录了压缩列表包含的节点数量，entryX压缩列表包含的各个节点，节点的长度由节点保存的内容而定，zlend用来标记压缩列表的尾端

## 7.2 压缩列表节点的构成
- 每个压缩节点可以保存一个字节数组或者一个整数值
- 每个压缩列表节点都由previous_entry_length、encoding、content三个部分构成

### 7.2.1 previous_entry_length
以字节为单位，记录了压缩列表中前一个节点的长度。长度可以是1字节或者5字节

### 7.2.2 encoding
记录节点的content属性所保存数据的类型和长度

### 7.2.3 content
保存节点的值

## 7.3 连锁更新
previous_entry_length1字节到5字节的变化，可能导致添加和删除都可能产生连锁更新，连锁更新最坏复杂度为o(n2)，因为概率低，实际ziplistPush的平均复杂度为o(n)

# 第8章 对象
Redis并没有使用之前讲的数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统

## 8.1 对象的类型与编码
- 每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）
- Redis中每个对象都由一个redisObject结构表示，type类型，encoding编码，ptr指向底层实现数据结构的指针

### 8.1.1 类型
- type可以是REDIS_STRING字符串对象，REDIS_LIST列表对象，REDIS_HASH哈希对象，REDIS_SET集合对象，REDIS_ZSET有序集合对象
- TYPE命令可以看值的对象类型

### 8.1.2 编码和底层实现
- ptr指向对象的底层实现数据结构，数据结构由对象的encoding决定
- 使用OBJECT ENCODING可以查看数据库键的值对象的编码
- 每种类型的对象都至少使用了两种不同的编码
- 整数：int，embstr编码的简单动态字符串：embstr，简单动态字符串：raw，字典：hashtable，双端链表：linkedlist，压缩列表：ziplist，整数集合：intset，跳跃表和字典：skiplist

## 8.2 字符串对象
- 字符串的UI想的编码可以是int、raw或者embstr
- 如果一个字符串保存的是整数值，并且可以用long类型表示，则会使用编码int
- 如果字符串对象保存的是一个字符串值，并且长度大于39字节，那么使用一个简单动态字符串（SDS）保存这个字符串值，编码设置为raw
- 如果字符串保存的是一个字符串值，并且字符串长度小于39字节，编码为embstr。embstr编码所需内存分配次数从raw的两次变1次，释放内存只需要1次，所有的数据都在一块连续的内存里面，能更好的利用缓存带来的优势。
- long double表示的浮点数在redis里面是作为字符串值来保存的

### 8.2.1 编码的转换
- int编码执行一些命令，对象存的不再是整数值，而是一个字符串，则字符串编码从int变为raw
- embstr在任何修改命令，都会编码变成raw

### 8.2.2 字符串命令的实现
SET，GET，APPEND，INCRBYFLOAT，INCRBY，DECRBY，STRLEN，SETRANGE，GETRANGE

## 8.3 列表对象
- 列表对象编码可以是ziplist或者linkedlist
- ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素。
- RPUSH命令
- linkedlist编码的列表使用双端链表作为底层实现，底层的双端链表结构中包含了字符串对象
- 字符串对象是Redis五中类型的对象中唯一一种会被其他四种对象嵌套的对象

### 8.3.1 编码转换
当列表对象满足一下两个条件，编码使用ziplist，不满足则使用linkedlist
- 列表对象保存到 所有字符串元素长度小于64字节
- 列表对象保存的元素数量小512个

### 8.3.2 列表命令的实现
LPUSH，RRPUSH，LPOP，RPOP，LINDEX，LLEN，LINSERT，LREM，LTRIM，LSET

## 8.4 哈希对象
- 哈希对象的编码可以是ziplist或者hashtable
- ziplist编码的哈希对象使用压缩列表作为底层实现，保存了同一键值对的两个节点总是紧挨着一起，保存键的节点在前，保存值的节点在后。先添加到哈希对象的键值对会被放在压缩列表的表头方向，后添加的被放在压缩列表的表尾方向。
- HSET命令
- hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存，字典的每个键都是一个字符串对象，对象中保存了键值对的键，字典的每个值都是一个字符串对象，对象中保存了键值对的值。

### 8.4.1 编码转换
当哈希对象可以同时满足两个一下条件，则使用ziplist编码。否则使用hashtable
- 哈希对象保存的所有键值对的键和值字符串长度都小于64字节
- 哈希对象保存的键值对数量小于512

### 8.4.2 哈希命令的实现
HSET，HGET，HEXISTS，HDEL，HLEN，HGETALL

## 8.5 集合对象
- 集合对象的编码可以是intset或者hashtable
- intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面
- hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则设为NULL
- SADD指令

### 8.5.1 编码的转换
当集合对相关同时满足以下两个条件，对象使用intset编码，不满足则使用hashtable
- 集合对象保存的所有元素都是整数值
- 集合对象保存的元素数量不超过512个

### 8.5.2 集合命令的实现
SADD，SCARD，SISMEMBER，SMEMBERS，SRANDMEMBER，SPOP，SREM

## 8.6 有序集合对象
- 有序集合的编码可以是ziplist或者skiplist
- ziplist编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个保存元素的分值。分数低的在表头，分数高的在表尾
- ZADD指令
- skiplist编码的有序集合列表使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表。zset中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点保存了一个集合元素。跳跃表节点object属性保存了元素的成员，节点score属性保存了分值。zset结构中的dict字典为有序集合创建了一个从成员到分数的映射。
- 有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是double。两种数据结构都会使用指针共享相同元素的成员和分值。

### 8.6.1 编码的转换
当有序集合对象可以同时满足以下两个条件，使用ziplist，否则使用skiplist
- 有序集合保存的元素数量小于128个
- 有序集合保存的所有元素成员的长度都小于64字节

### 8.6.2 有序集合命令的实现
ZADD，ZCARD，ZCOUNT，ZRANGE，ZREVRANGE，ZRANK，ZREEM，ZSCORE

## 8.7 类型检查与命令多态
- 对任何键都可以执行：DEL、EXPIRE、RENAME、TYPE、OBJECT
- SET、GET、APPEND、STRLEN只能对字符串键执行
- HDEL、HSET、HGET、LEN只能对哈希键执行
- RPUSH、LPOP、LINSERT、LLEN只能对列表建
- SADD、SPOP、SINTER、SCARD只能对集合键执行
- ZADD、ZCARD、ZRANK、ZSCORE只能对有序集合键执行

### 8.7.1 类型检查的实现
举个例子：客户端发送LLEN <key>命令，服务器检查键key的值对象是否列表对象，是则对键key执行LLEN命令，否则返回一个类型错误。

### 8.7.2 多态命令的实现
我们可以认为LEN命令是多态的，只要执行LLEN命令的是列表键，那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都能正常运行。

## 8.8 内存回收
- C语言并不具备自动回收功能，Redis在自己的对象系统中构建了一个引用计数技术实现内存回收机制。redisObject的refcount属性
- 创建一个新对象，refcount为1，被一个应用程序使用则加1，不再被程序使用则减1，引用值变为0，对象所占用内存会被释放

## 8.9 对象共享
- 让多个键共享同一个值对象需要执行两个步骤：将数据库键的值指针指向一个现有的值对象；将被共享的值对象的引用计数加1.
- 目前来说，Redis会在初始化服务器时，创建一万个字符串的UI想，这些对象包含了从1-9999的所有整数值，当服务器需要到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。
- 为什么Redis不共享包含字符串的对象？共享对象时保存整数的字符串对象，验证操作O(1)，共享对象是字符串值的字符串对象，验证复杂度O(N)，包含了多个值（或者对象）的对象，比如列表对象或者哈希对象，验证复杂度O(n2)，尽管共享更复杂的对象可以节约更多的内存，但受到CPU时间的限制，Redis只对包含整数值的字符串对象进行共享。

## 8.10 对象的空转时长
除了type，encoding，ptr和refcount四个属性外，redisObject结构包含的最后一个属性为lru属性，改属性记录了对象最后一次被命令程序访问的时间。OBJECT IDLETTIME可以打印出给定键的空转时长，空转时长就是当前时间减去键值对象lru时间计算得出的。

# 第9章 数据库

## 9.1 服务器中的数据库
Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库。Redis默认创建16个数据库

## 9.2 切换数据库
客户端可以通过执行SELECT命令来切换目标数据库。redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针。客户端切换可能忘记当前使用哪个数据库，所以当执行FLUSHDB这样危险命令之前，最好先执行一个SELECT命令，显式地切换到指定的数据库，然后再执行别的命令。

## 9.3 数据库键空间
- Redis是一个键值对数据库服务器，服务器中的每个数据库都是由一个redis.h/redisDb结构表示，其中redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间。
- 键空间的键也就是数据库中的键，每个键都是一个字符串对象
- 键空间的值也就是数据库的值，可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。

### 9.3.1 添加新键
添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象

### 9.3.2 删除键
删除数据库中的一个键，实际上就是在键空间里面删除键锁对应的键值对对象

### 9.3.3 更新键
对一个数据库键进行更新，实际上是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。

### 9.3.4 对键取值
对一个数据库键进行取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同

### 9.3.5 其他键空间操作
清空整个数据库FLUSHDB命令、随机返回数据库中某个键的RANDOMKEY命令、返回数据库键数量DBSIZE命令、EXISTS、RENAME、KEYS都是通过键空间进行操作来实现的。

### 9.3.6 读写键空间时的维护操作
当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作，例如
- 读取一个键后（读操作或者写操作都要对键进行读取），服务器会根据键是否存在来更新服务器键空间中（hit）次数或键空间不命中（miss）次数，这两个值在INFO stats命令的keyspace_hits和keyspace_misses查看
- 读取一个键后，服务器会更新LRU时间，OBJECT idletime <key>查看
- 读取一个键后，发现键已经过期，会先删除这个键再执行其他操作
- 如果客户端WATCH命令监听了某个键，那么服务器对监视的键进行修改，会将这个键标记为脏（dirty），从而事务知道被修改过
- 服务器每次修改一个键后，都会对脏（dirty）加1，这个计数器会出发服务器的持久化以及复制
- 如果服务器开启了数据库通知功能，那么键修改后会按照配置发送响应的数据库通知

## 9.4 设置键的生存时间或过期时间
通过EXPIRE命令或者PEXPIRE命令可以以秒或者毫秒为数据库的某个键设置生存时间。通过EXPIREAT命令或者PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间。TTL命令和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余时间。

### 9.4.1 设置过期时间
EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的

### 9.4.2 保存过期时间
redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个为过期字典：
- 过期字典的键是一个指针，这个指针指向键空间中的某个键对象
- 过期字典的值是一个long类型的整数，保存了键所指向数据库的过期时间，一个毫秒精度的UNIX时间戳

### 9.4.3 移出过期时间
PERSIST命令可以移出一个键的过期时间

### 9.4.4 计算并返回剩余生存时间
TTL命令个以秒为单位返回剩余时间，PTTL返回毫秒的剩余生存时间。都是计算键的过期时间和当前之间的差值来实现的。

### 9.4.5 过期键的判定
- 检查给定键是否存在过期字典，如果存在取出键的过期时间
- 检查当前UNIX时间戳是否大于键的过期时间，如果是那么键过期，否则键未过期

## 9.5 过期键删除策略

### 9.5.1 定时删除
- 定期删除通过定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用内存
- 缺点是，对CPU时间不友好，在过期键比较多的时候，删除的时候会占用一部分CPU时间，对吞吐量和响应时间造成影响

### 9.5.2 惰性删除
- 程序只会在取出键对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行
- 缺点是对内存不友好，如果一个键过期，而这个键又仍保留在内存中。
- 如果永远不访问键，则永远不会被删除（除非用户手动执行FLUSHDB），可以称为一种内存泄露

### 9.5.3 定期删除
- 每隔一段时间执行一次删除过期操作，并通过限制删除执行的时长和频率来减少删除操作对CPU时间的影响
- 通过定期删除过期键，有效的减少了因为过期键而带来的内存浪费

## 9.6 Redis的过期键删除策略
Redis使用惰性删除和定期删除两种策略

### 9.6.1 惰性删除策略的实现
- 惰性删除策略在db.c/expireIfNeeded函数实现，所有读写都会调用expireIfNeeded函数进行检查
- 每个命令都应该能处理当键存在和不存在的情况

### 9.6.2 定期删除策略的实现
定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作recdis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机一部分键的过期时间，并删除其中的过期键。

## 9.7 AOF、RDB和复制功能对过期键的处理

### 9.7.1 生成RDB文件
在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中

### 9.7.2 载入RDB文件
启动Redis的时候，如果开启了RDB，将载入RDB文件
- 如果服务器以主服务器模式运行，程序会对文件中保存的键进行检查，过期的则被忽略
- 如果服务器以从服务器模式运行，不论是否过期，都会载入到数据库中。主从同步的时候，从服务器的过期数据会被删掉

### 9.7.3 AOF文件写入
当服务器以AOF持久化模式运行时，如果服务器中的某个键已经过期，但它还没来得及惰性删除或者定期删除，那么AOF文件不会因为这个键过期而产生任何影响。因为在删除的时候程序会追加一条命令，来显示地记录该键被删除。

### 9.7.4 AOF重写
在执行AOF重写的时候，程序会对数据库中的键进行检查，已经过期的键不会被保存到重写后的AOF文件中。

### 9.7.5 复制
当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：
- 主服务器在删除一个过期键之后，会显示地向所有的从服务器返送一个DEL命令，告知从服务器删除这个过期键
- 从服务器在执行客户端命令时，即使碰到过期键也不会将过期键删除，而是像处理未过期键一样处理过期键
- 从服务器只有在接收到主服务器发来的DEL命令之后，才会删除过期键

## 9.8 数据库通知
- 数据库通知可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。
- 这一类关注“某个键执行了什么命令”的通知称之为键空间通知
- 另一类成为键事件通知，它们关注的是”某个命令被什么键执行了”

### 9.8.1 发送通知
- 由notify.c/notifyKeyspaceEvent函数实现
- type是当前想发送的通知的类型，event、keys和dbid分别是事件的名称、产生的事件的键、以及产生事件的数据库号码

### 9.8.2 发送通知的实现
pubsubPublishMessage函数是PUBLISH命令的实现函数，执行这个函数等同于执行PUBLISH命令，订阅数据库通知的客户端收到的信息就是由这个函数发出的。

# 第10章 RDB持久化
- 我们将数据库中的非空数据库以及它们的键值对统称为数据库状态
- Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失

## 10.1 RDB文件的创建与载入
- 有两个Redis命令可以生成RDB文件，SAVE会阻塞Redis服务器进程，不能处理任何请求，直到RDB文件创建完毕为止，BGSAVE会派生一个子进程，父进程继续处理请求。
- 创建RDB文件的实际工作是由rdb.c/rdbSave函数完成
- RDB文件的载入是在服务器启动时自动执行的，由rdb.c/rdbLoad函数完成
- 如果开启了AOF持久化，优先使用AOF，只有AOF关闭状态，服务器才会使用RDB文件

### 10.1.1 SAVE命令执行时的服务器状态
执行SAVE，客户端发送的所有命令都会被阻塞。只有执行完SAVE，重新开始接收命令请求之后，客户端发来的命令才会被处理

### 10.1.2 BGSAVE命令执行时的服务器状态
执行BGSAVE后，客户端的SAVE命令会被服务器拒绝；发送的BGSAVE也会被拒绝；BGREWRITEAOF命令会被延迟到BGSAVE完成后执行。如果BGREWRITEAOF在执行，BGSAVE会被拒绝。

### 10.1.3 RDB文件载入时的服务器状态
服务器在载入RDB文件期间，会一直处于阻塞状态，知道载入工作完成为止。

## 10.2 自动间隔性保存
save选项设置多个保存条件，但其中任意一个条件被满足，服务器就会执行BGSAVE命令。save 秒数 至少多少次修改

### 10.2.1 设置保存条件
根据save所设置的保存条件，设置服务器状态redisServer结构的saveparams数组，每个都是saveparam结构，保存了秒数和修改数

### 10.2.2 dirty计数器和lastsave属性
dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态进行了多少次修改（包括写入、删除、更新等操作）；lastsave属性是一个UNIX时间戳，记录上一次成功执行SAVE或者BGSAVE的时间。

### 10.2.3 检查保存条件是否满足
serverCron每100毫秒就会执行一次，有一项就是检查save选项所设置的保存条件是否已经满足，如果满足的话就执行BGSAVE命令。

## 10.3 RDB文件结构
RDB文件最开头是REDIS字符占5个字节，db_version为4个字节，databases包含着零个或任意多个数据库，EOF长度为1字节标志着正文结束，check_sum是8字节无符号整数，保存着校验和。

### 10.3.1 databases部分
如果0和3号数据库非空，则创建database 0和database 3，每个非空RDB都可以保存为SELECTDB、db_number、key_value_pairs三个部分。SELECTDB为1字节，当程序读入这个就会知道后面是数据库号码。db_number为1字节、2字节或者5字节，读入后则调用选择数据库命令。key_value_pairs保存了数据库中所有的键值对数据。

### 10.3.2 key_value_pairs部分
- 不带过期时间的键值对在RDB文件中由TYPE、key、value三部分组成
- 带过期的时间的键值对在RDB文件中EXPIRETIME_MS、ms、TYPE、key、value

### 10.3.3 value编码
- RDB每个value部分都保存了一个值对象，每个值对象的类型都由与之对应的TYPE记录，根据类型的不同，value部分的结构、长度也会有所不同
  1. 字符串对象
     1. 如果字符串编码是REDIS_ENCODING_INT，那么可以用ENCODING|integer存储
     2. 如果字符串对象编码是REDIS_ENCODING_RAW，格式len|string，字符串长度小于等于20字节，被原样存储。大于20字节，被压缩存储
  2. 列表对象
     1. TYPE为REDIS_RDB_TYPE_LIST，value保存的是REDIS_ENCODING_LINKEDLIST编码的列表对象
     2. 格式为：list_length|item1|item2...|itemN
  3. 集合对象
     1. TYPE为REDIS_RDB_TYPE_SET，value保存的是REDIS_ENCODING_HT编码的集合对象
     2. 格式为：set_size|elem1|elem2...|elemN
  4. 哈希表对象
     1. TYPE为REDIS_RDB_TYPE_HASH，value就是REDIS_ENCODING_HT编码的集合对象
     2. 格式为：hash_size|key_value_pair 1|key_value_pair2...|key_value_pair N
  5. 有序集合对象
     1. 如果TYPE为REDIS_RDB_TYPE_ZSET，那么value保存的是REDIS_ENCODING_SKIPLIST编码的有序集合对象
     2. 格式为：sorted_set_size|element1|element2...|elementN
  6. INTSET编码的集合
     1. TYPE为REDIS_RDB_TYPE_SET_INTSET，value就是一个整数集合对象
     2. 先将整数集合转化为字符串对象，然后将这个字符串对象保存在RDB文件里面
  7. ZIPLIST编码的列表、哈希表或者有序集合
     1. TYPE为REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST或者REDIS_TYPE_ZSET_ZIPLIST，那么value就是一个压缩列表对象
     2. 将压缩列表转化为一个字符串对象
     3. 将转换所得的字符串对象保存在RDB文件中

## 10.4 分析RDB文件
- 用od命令来分析Redis产生的RDB文件，-c以ASCII打印，-x以十六进制打印

### 10.4.1 不包含任何键值对的RDB文件
- 五个字节的“REDIS”字符串
- 四个字节的版本号
- 一个字节的EOF常量
- 八个字节的校验和

### 10.4.2 包含字符串的RDB文件
- 一个一字长的特殊值SELECTDB
- 一个长度可能为一字节、两字节或者五字节的数据库号码
- 一个或以上数量的键值对

### 10.4.3 包含带有过期时间的字符串键的RDB文件
- 一个一字节长的EXPIRETIME_MS特殊值
- 一个八字节长的过期时间(ms)
- 一个一字节长的类型(TYPE)
- 一个键(key)和一个值(value)

### 10.4.4 包含一个集合键的RDB文件
- 集合的大小
- 集合元素

### 10.4.5 关于分析RDB文件的说明
- Redis本身检查工具redis-check-dump
- -cx调用od命令可以同时以ASCII和十六进制打印

# 第11章 AOF持久化
- AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。

## 11.1 AOF持久化的实现
- AOF持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤

### 11.1.1 命令追加
- 当AOF持久化处于打开状态，服务器在执行完一个写命令后，会以协议格式将执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。

### 11.1.2 AOF文件的写入与同步
- Redis的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。
- 在服务器每次结束一个事件循环之前，都会调用flushAppendOnlyFile函数，考虑是否将aof_buf缓冲区中的内容写入和保存到AOF文件里面。
- appendfsync默认为everysec
- 操作系统一般会将写入数据暂时保存一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才会真正地将缓冲区中的数据写入磁盘。如果计算机停机，那么保存在内存缓冲区的写入数据将会丢失你。fsync和fdatasync可以保证立即写入磁盘

## 11.2 AOF文件的载入与数据还原
- 创建一个不带网络连接的伪客户端，因为Redis的命令只能在客户端上下文执行，载入AOF文件
- 从AOF文件中分析并读取出一条写命令
- 使用伪客户端执行被读出的写命令
- 一直执行上述步骤，直到AOF文件中的所有写命令都被处理完毕

## 11.3 AOF重写
- 为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写功能，可以创建一个新的AOF文件来替代现有的AOF文件，新AOF文件不会包含任何浪费空间的冗余命令，体积小的多

### 11.3.1 AOF文件重写的实现
- AOF重写是读取服务器当前的数据库状态实现的
- 首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理。
- 在实际中，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合，会检查包含的元素数是否大于rREDIS_AOF_REWRITE_ITEMS_PER_CMD，如果超过则拆分多个命令

### 11.3.2 AOF后台重写
- Redis将AOF重写程序放在子进程里执行
- 子进程进行AOF重写期间，服务器进程（父进程）可以处理命令请求
- 子进程带有服务器进程的数据副本，使用子进程而不是线程，可以避免使用锁的情况下，保证数据的安全性
- 为了解决数据不一致，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写明令之后，它同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区
- 当子进程完成AOF重写工作后，它像父进程发送一个信号，父进程会调用一个信号处理函数，执行以下工作
  1. 将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件保存的数据库状态和服务器对当前的数据库状态一致
  2. 对新的AOF文件进行改名，原子性（atomic）覆盖现有的AOF文件，完成新旧两个AOF文件的替换
  3. 信号处理完后，父进程可以继续接受命令请求
- AOF后台重写命令为BGREWRITEAOF命令

# 第12章 事件
- 文件事件：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。
- 时间事件：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类操作的抽象。

## 12.1 文件事件
- 文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器
- 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的时间处理器来处理这些事件

### 12.1.1 文件事件处理器的构成
- 四个组成部分，分别是套接字、I/O多路复用程序、文件事件分派器、以及事件处理器
- 尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字放到一个队列里面、然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕），I/O多路复用程序才会继续向事件分派器传送下一个套接字。

### 12.1.2 I/O多路复用程序的实现
- 通过包装常见的select、epoll、evport和kqueue这些I/O多路复用函数库来实现
- 程序会在编译时自动选择系统中性能最高的I/O多路复用函数库来作为Redis的I/O多路复用程序的底层实现

### 12.1.3 事件的类型
- 当套接字变得可读时（客户端对套接字执行write操作，或者执行close操作），或者有新的可应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行connect操作），套接字产生AE_READABLE事件
- 当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件
- 如果一个套接字可读又可写，服务器先处理读套接字，后写套接字

### 12.1.4 API
- ae.c/aeCreateFileEvent函数接受一个套接字描述符、一个事件类型、以及一个时间处理器作为参数，将给定套接字的事件加入到I/O多路复用程序的监听范围之内，并对事件和事件处理器进行关联

### 12.1.5 文件事件的处理器
- 连接应答处理器：Redis服务器进行初始化的时候，程序会将这个连接应答处理器和服务器监听套接字的AE_READABLE事件关联起来
- 命令请求处理器：这个处理器负责从套接字中读入客户端发送的命令请求内容，当客户端向服务器发送命令请求的时候，套接字就会产生AE_READABLE事件，引发命令请求处理器执行，并执行相应的套接字读入操作。当客户端连接服务器的整个过程中，服务器都会一直为客户端的AE_READABLE事件关联命令请求处理器
- 命令回复处理器：当服务器有命令回复需要传送给客户端的时候，服务器会将客户端套接字的AE_WRITABLE事件和命令回复处理器关联起来，当客户端准备挨好接受服务器传来的命令回复时，就会产生AE_WRITABLE事件，引发命令回复处理器执行，并执行相应的套接字写入操作。当发送完毕后，就会解除关联

## 12.2 时间事件
- 定时事件：让一段程序在制定的时间之后执行一次
- 周期性时间：让一段程序每隔制定时间就执行一次
- 一个时间事件主要由id，when，timeProc组成

### 12.2.1 实现
- 服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的时间处理器

### 12.2.2 API
- ae.c/aeCreateTimeEvent函数接受一个毫秒数miilliseconds和一个时间事件处理器proc作为参数，将一个新的时间事件添加到服务器
- ae.c/aeDeleteFileEvent函数接受一个时间事件ID作为参数，然后从服务器中删除该ID所对应的时间事件
- ae.c/aeSearchNearestTimer函数返回到达时间距离当前时间最接近的那个时间事件。
- ae.c/processTimeEvents是时间事件的执行器，这个函数会遍历所有时间事件，并调用事件处理器来处理那些已到达的时间事件。

### 12.2.3 时间事件应用实例：serverCron函数
- 更新服务器的各类统计信息、比如时间、内存占用、数据库占用情况等
- 清理数据库中的过期键值对
- 关闭和清理链接失效的客户端
- 尝试进行AOF或RDB持久化操作
- 如果服务器是主服务器，那么对从服务器进行定期同步
- 如果处于集群模式，对集群进行定期同步和连接测试

## 12.3 事件的调度与执行
- 事件的调度和执行由ae.c/aeProcessEvents函数负责
- aeApiiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间决定
- 因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件
- 对文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占
- 命令回复处理器将一个命令回复写入到客户端套接字时，如果写入字节数超过了一个预设置常量的话，命令回复处理器就会主动break跳出写入循环，将余下的数据留到下次再写。另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。
- 时间事件的实际处理时间通常会比设定的到达时间稍晚一些


# 第13章 客户端
- 通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信
- 对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis.h/redisClient结构（客户端状态），这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构

## 13.1 客户端属性
- 一类是比较通用的属性
- 另外一类是和特定功能相关的属性

### 13.1.1 套接字描述符
- 客户端状态的fd属性记录了客户端正在使用的套接字描述符
- 伪客户端的fd为-1，命令请求来自AOF文件或者Lua脚本，而不是网络，这种客户端不需要套接字
- 普通客户端的fd为大于-1的整数，服务器使用fd属性来记录客户端套接字的描述符
- CLIENT list命令可恶意列出目前所有连接到服务器的普通客户端

### 13.1.2 名字
- 使用CLIENT seetname命令可以为客户端设置一个名字
- 客户端的名字记录在客户端状态的name属性里面

### 13.1.3 标志
- 客户端的标志属性flags记录了客户端的角色，以及客户端目前所处的状态

### 13.1.4 输入缓冲区
- 客户端状态的输入缓冲区用于保存客户端发送的命令请求

### 13.1.5 命令与命令参数
- 服务器解析客户端状态的querybuf，得出命令参数和命令参数个数分别保存到客户端状态argv和argc属性
- argv[0]是命令，其他是参数

### 13.1.6 命令的实现函数
- 服务器根据项argv[0]的值，查找对应的命令实现函数
- 当程序在命令表中找到argv[0]所对应的redisCommand结构时，它会将客户端状态的cmd指针指向这个结构

### 13.1.7 输出缓冲区
- 执行命令的回复都会保存在客户端状态的输出缓冲区里面，输出缓冲区一个是固定的，一个是可变的
- 固定大小的缓冲区用于保存那些长度比较小的回复，比如OK、简单的字符串值、整数值、错误回复等
- 可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等
- 固定大小使用buf默认16KB，bufpos记录了目前已经使用的长度。可变缓冲区由reply通过链表来连接多个字符串对象

## 第14章 服务器
- Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令锁产生的数据，并通过资源管理来维持服务器自身的运转

## 14.1 命令请求执行过程
- 客户端向服务器发送命令请求SET KEY VALUE
- 服务器接收并处理客户端发来的命令请求SET KEY VALUE，在数据库中进行设置操作，并产生命令回复OK
- 服务器将命令回复OK发送给客户端
- 客户端接收服务器返回的命令回复OK，并将这个回复打印给用户观看

### 14.1.1 发送命令请求
- Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式命令请求发送给服务器

### 14.1.2 读取命令请求
- 读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面
- 对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv和argc里面
- 调用命令执行器，执行客户端指定的命令

### 14.1.3 命令执行器（1）：查找命令实现
- 命令表是一个字典，字典的键是一个个命令名字，比如"set", "get", "del"等，字典的值是redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息
- SET命令的名字为"set"，实现函数为setCommand，命令参数个数为-3，标识命令接受三个或以上数量的参数；命令的标识为wm，标识SET命令是一个写入命令，并且在执行这个命令之前，服务器应该对占用内存进行检查，因为这个命令会占用大量内存
- GET命令的名字为"get"，实现函数为getCommand，命令的参数个数为2，标识命令只接受两个参数，命令的标识为"r"，表示这是一个只读命令

### 14.1.4 命令执行器（2）：执行预备操作
- 检查客户端状态的cmd指针是否为NULL，如果是的话，说明用户输入命令找不到相应的命令实现，服务器不会继续执行
- 根据cmd的redisCommand结构的artity属性，检查命令给的参数是否正确
- 检查客户端是否已经通过了身份验证
- 服务器打开了maxmemory功能，执行命令之前，检查服务器的内存占用情况，在有需要的时候进行内存回收，内存回收出错则返回错误
- 如果服务器上一次执行BGSAVE命令时出错，并打开了stop-writes-on-bgsave-error功能，服务器要执行写命令，服务器将拒绝这个命令
- 如果客户端正在用SUBSCRIBE命令订阅频道，或正在用PSUBSCRIBE命令订阅模式，那么服务器只会执行SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE四个命令
- 如果服务器正在进行数据载入，那么客户端发送的命令必须带有l标识（比如INFO、SHUTDOWN、PUBLISH等等）才会被服务器执行
- 如果服务器因为执行Lua脚本而超时并进入阻塞状态，服务器智慧执行客户端发来的SHUTDOWN nosave命令和SCRIPT KILL命令
- 如果客户端正在执行事务，那么服务器只会执行客户端发来的EXEC、DISCARD、MULTI、WATCH四个命令
- 如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数等信息发送给监视器
- 完成上述所有预备操作后，就会真正执行命令了

### 14.1.5 命令执行器（3）：调用命令的实现函数
- 服务器决定要执行命令的时候，调用client->cmd->proc(client);对于SET命令，相当于执行setCommand(client);
- 命令执行的回复放在输出缓冲区里面（buf属性和reply属性），之后还会为客户端关联命令回复处理器

### 14.1.6 命令执行器（4）：执行后续工作
- 如果服务器开启了慢查询日志，慢查询日志模块会检查刚才执行的命令是否需要加日志
- 根据所消耗的的时长，更新redisCommand的milliseconds属性，并将calls加一
- 如果开启了AOF持久化功能，将刚才的命令请求写入到AOF缓冲区里面
- 如果有其他服务器正在复制当前的服务器，命令会广播到其他服务器
- 当上述操作都执行完了，服务器就可以继续从文件事件处理器取出并处理下一个命令请求了

### 14.1.7 将命令回复发送给客户端
- 命令实现函数会将命令回复保存到客户端的输出缓冲区里面
- 并为客户端的套接字关联命令回复处理器
- 当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端缓冲区的命令回复发送给客户端

### 14.1.8 客户端接收并打印命令回复
- 当客户端接收到写协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户看

## 14.2 serverCron函数
- Redis的serverCron每隔100ms执行一次

### 14.2.1 更新服务器时间缓存
- 避免调用系统时间的系统调用，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存，每隔100ms更新一次，这两个时间精度不高
- 服务器只会在打印日志、更新服务器的LRU始终、决定是否执行持久化任务、计算服务器上线时间堆时间精度要求不高使用unixtime和mstime属性
- 对于为键设置过期时间、添加慢查询日志这种需要高精度时间的功能来说，服务器还是再次执行系统调用获取最准确是时间

### 14.2.2 更新LRU时钟
- 服务器状态的lruclock保存了服务器的LRU时钟
- 每个Redis对象都会有一个lru属性，保存对象最后一次被命令访问的时间
- lruclock-lru计算对象的空转时间
- serverCron会以每10s更新一次lruclock属性的值

### 14.2.3 更新服务器每秒执行命令次数
- serverCron函数的trackOperationsPerSecond函数会以每100毫秒一次的频率执行，可以通过INFO status的instantaneous_ops_per_sec查看，计算的是估算值

### 14.2.4 更新服务器内存峰值记录
- 服务器状态的stat_peak_memory记录了服务器的内存峰值大小
- serverCron每次执行都会查看服务器当前内存使用量，如果比这个值大就会更新
- INFO memory的used_memory_peak和used_memory_peak_human两个值分别以两种格式记录了服务器的内存峰值

### 14.2.5 处理SIGTERM信号
- Redis为SIGTERM关联sigtermHandler函数，接收到信号，打开服务器状态的shutdown_asap标识，serverCron每次都会检查shtdown_asap属性进行检查，为1的时候关闭服务器

### 14.2.6 管理客户端资源
- serverCron每次都会调用clientsCron函数，会有两个检查
  1. 如果客户端与服务器之间的连接已超时，程序释放这个客户端
  2. 如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存

### 14.2.7 管理数据库资源
- serverCron每次都调用databasesCron，进行数据检查，删除其中的过期键，并在有需要的时，对字典进行收缩操作

### 14.2.8 执行被延时的BGREWRITEAOF
- 如果执行BGSAVE命令期间，客户端发来BGREWRITEAOF命令，那么服务器会将BGREWRITEAOF命令执行时间延迟到BGSAVE命令执行完毕之后
- aof_rewrite_scheduled记录了服务器是否延迟了BGREWRITEAOF

### 14.2.9 检查持久化操作的运行状态
- 服务器状态rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程ID
- 每次serverCron执行，都会检查这两个属性，如果其中一个属性不为-1，程序就会执行一次wait3函数，检查子进程是否有信号发来服务器进程
- 如果有信号到来，说明RDB文件已经生成完毕或者AOF文件已经重写完毕，服务器进行后续操作，比如用新的RDB替换老的，重写后的AOF替换之前的
- 如果没有信号到达，标识持久化操作未完成，程序不做任何动作

### 14.2.10 将AOF缓冲区的内容写入AOF文件
- 如果服务器开启了AOF持久化功能，并且AOF缓冲区里面有待写入的数据，那么serverCron会调用相应程序，将AOF缓冲区的内容写入到AOF文件里面

### 14.2.11 关闭异步客户端
- 在这一步，服务器会关闭那些输出缓冲区大小超出限制的客户端

### 14.2.12 增加cronloops计数器的值
- 服务器状态的cronloops记录了serverCron函数执行的次数，serverCron没执行一次，这个就会加1

## 14.3 初始化服务器

### 14.3.1 初始化服务器状态结构
- redisServer实例变量由redis.c/initServerConfig函数完成
- 设置服务器的运行ID
- 设置服务器的默认运行频率
- 设置服务器的默认配置文件路径
- 设置服务器的运行架构
- 设置服务器的默认端口号
- 设置服务器的默认RDB持久化条件和AOF持久化条件
- 初始化服务器的LRU时钟
- 创建命令表

### 14.3.2 载入配置选项
- 启动服务器时，用户可以给定配置参数或者指定配置文件来修改服务器的默认配置，redis-server --port 10086; redis-server redis.conf

### 14.3.3 初始化服务器数据结构
- server.clients链表，记录所有与服务器相连的客户端的状态结构
- server.db数组，数组中包含了服务器的所有数据库
- 用于保存频道订阅信息的server.pubsub_channels字典，以及用于保存模式订阅信息的server.pubsub_patterns链表
- 用于执行Lua脚本的Lua环境server.lua
- 用于保存慢查询日志的server.slowlog属性
- 接着调用initServer为以上提到的数据结构分配内存，如果有需要，为这些数据结构设置或者关联初始化值
- 除了初始化数据结构之外，initServer还进行了一些非常重要的设置操作，其中包括
  1. 为服务器设置进程信号处理器
  2. 创建共享对象：这些包含Redis服务器惊颤个用到的一些志，比如"OK"， 1到1000的字符串对象等
  3. 打开服务器的监听端口，并为监听套接字关联连接应答处理器
  4. 为serverCron函数创建时间事件
  5. 如果AOF持久化功能已经打开，那么打开现有的AOF文件，如果不存在，则创建一个新的AOF文件
  6. 初始化服务器的后台I/O模块(bio)，为将来的I/O操作做好准备

### 14.3.4 还原数据库状态
- 如果服务器启用了AOF持久化功能，那么服务器使用AOF文件来还原数据库状态
- 如果没有启用AOF持久化功能，那么服务器使用RDB文件来还原数据库状态

### 14.3.5 执行事件循环
- 至此，服务器的初始化工作圆满完成，服务器现在开始可以接受客户端的连接请求，并处理客户端发来的命令请求了。

# 第15章 复制
- 在Redis中，用户可以通过SLAVEOF命令或者设置slaveof选项，让一个机器去复制另外一个机器

## 15.1 旧版复制功能的实现
- 同步操作用于将服务器的数据库状态更新至主服务器所处的状态
- 命令传播操作则用于主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态

### 15.1.1 同步
- 从服务器发送SYNC命令进行同步，步骤如下：
  1. 从服务器向主服务器发送SYNC命令
  2. 收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并用一个缓冲区记录从现在开始执行的写命令
  3. 当主服务器BGSAVE执行完毕时，主服务器将BGSAVE命令生成的RDB文件发送给从服务器，从服务区接收并载入这个RDB文件
  4. 主服务器将记录在缓冲区里面的所有写命令发送给从服务器

### 15.1.2 命令传播
- 主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令，主从服务器将再次回到一致状态。

## 15.2 旧版复制功能的缺陷
- 断线重连，需要重新SYNC，是一个非常耗费资源的操作

## 15.3 新版复制功能的实现
- Redis从2.8版本开始，使用PSYNC命令代替SYNC来执行复制时的同步操作，具有完整重同步和部分重同步
- 完整冲同步用于处理初次复制情况，和SYNC一样
- 部分重同步用于处理断线后重复制情况，将断连期间的写命令发送给从服务器

## 15.4 部分重复制的实现
- 主服务器的复制偏移量和从服务器的负债偏移量
- 主服务器的复制积压缓冲区
- 服务器的运行ID

### 15.4.1 复制偏移量
- 主服务器每次向从服务器传播N个字节的数据时，就将自己的偏移量值加上N
- 从服务器每次收到主服务器传播来的N个字节的数据，就将自己的复制便宜量加N

### 15.4.2 复制积压缓冲区
- 由主服务器维护一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小1MB
- 当主服务器进行命令传播时，它不仅将写命令发送给所有从服务器，还会将命令队列到复制挤压缓冲区里面，并对应每个字节记录相应的复制偏移量

### 15.4.3 服务器运行ID
- 每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID
- 运行ID在服务器启动时自动生成，40个速记的十六进制字符组成
- 断连后，根据从服务器发来的复制ID看是否等于当前ID来决定是否开启完整重同步

## 15.5 PSYNC命令的实现
- 如果从服务器以前没有复制过任何主服务器，需要进行完整重同步。PSYNC ? -1
- 部分重同步，从服务器发送PSYNC <runid> <offseet>命令，runid是上一次复制的主服务器的运行ID，offset是从服务器当前的复制偏移量

## 15.6 复制的实现
- 通过向从服务器发送SLAVEOF命令，我们可以让一个从服务器去复制一个主服务器，SLAVEOF <master_ip> <master_port>

### 15.6.1 步骤1：设置主服务器的地址和端口
- redisServer的masterhost记录主服务器的IP地址，masterport记录主服务器的端口号
- SLAVEOF是一个异步命令，完成masterhost和masterport，，服务器就返给客户端OK

### 15.6.2 步骤2：建立套接字连接
- 如果从服务器创建的套接字能成功连接到主服务器，那么从服务器将为这个套接字关联一个专门用于处理复制工作的文件事件处理器，比如处理器将负责后续的复制工作，接收RDB文件，以及接收主服务器传播来的写命令
- 从服务器是主服务器的客户端

### 15.6.3 步骤3：发送PING命令
- 虽然主从已经建立了套接字连接，但双方并没有使用过套接字进行过任何通信，通过发送PING命令可以检查套接字读写是否正常
- 因为复制工作接下来的几个步骤都必须在主服务器可以正常处理命令请求的状态下进行，发送PING命令可以检查是否可正常处理命令请求

### 15.6.4 步骤4：身份验证
- 从服务器收到"PONG"回复之后，下一步要决定是否做身份验证：
  1. 如果从服务器设置了masterauth选项，那么进行身份验证
  2. 如果从服务器没有设置masterauth选项，那么不进行身份验证

### 15.6.5 步骤5：发送端口信息
- 身份验证后，从服务器将执行命令REPLCONF listening-port <port-number>向主服务器发送从服务器的监听端口号

### 15.6.6 步骤6：同步
- 从服务器向主服务器发送PSYNC命令
- 同步操作执行之前，从服务器是主服务器的客户端，执行同步操作之后，主服务器也会成为从服务器的客户端
- 正因为主服务器成为了从服务器的客户端，所以主服务器才可以通过发送写命令来改变从服务器的数据库状态

### 15.6.7 步骤7：命令传播
- 主服务器值需要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收兵执行主服务器发A来的写命令，就可以保证主从服务器一直保持一致了。

## 15.7 心跳检测
- 在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令：REPLCONF ACK <replication_offseet>，其中replication_offset是从服务器当前的复制偏移量
- 检测主从服务器的网络连接状态
- 辅助实现min-slaves选项
- 检测命令丢失

### 15.7.1 检测主从服务器的网络连接状态
- 如果主服务器超过一秒钟没有收到从服务器发来的REPLCONF ACK命令，那么主服务器知道主从服务器之间的连接出现问题了
- 通过向主服务器发送INFO replication命令，列出从服务器列表的lag一栏中，我们可以看到相应从服务器最后一次向主服务器发送REPLCONF ACK命令距离现在过了多少秒

### 15.7.2 辅助实现min-slaves配置选项
- min-slaves-to-write 3表示从服务器的数量少于3个
- min-slave-max-lag 10表示或者三个从服务器的延迟值都大于或等于10秒时，主服务器键该拒绝执行写命令

### 15.7.3 检测命令丢失
- 如果主服务器传播给从服务器的写命令半路丢失，那么REPLCONF ACK发送给主服务器的时候，主服务器会意识到丢失，并将重新发送数据
- 发送缺失数据和部分重同步操作的原理相似，但不同的在于补发缺失数据操作在主从服务器没有断线的情况下执行，而部分重同步在主从服务器断线并重连后执行

# 第16章 Sentinel
- Sentinel是Redis的高可用性解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求

## 16.1 启动并初始化Sentinel
- redis-sentinel /path/to/your/sentinel.conf 或者 redis-server /path/to/your/sentinel.conf --sentinel
- 初始化服务器
- 将普通Redis服务器使用的代码替换成Sentinel专用代码
- 初始化Sentinel状态
- 根据给定的配置文件，初始化Sentinel的监视主服务器列表
- 创建连向主服务器的网络连接

### 16.1.1 初始化服务器
- Sentinel的本质只是一个运行在特殊模式下的Redis服务器，Sentinel初始化不需要载入RDB或者AOF

### 16.1.2 使用Sentinel专用代码
- 比如redis服务器端口为redis.h/REDIS_SERVERPORT，而Sentinel是sentinel.c/REDIS_SENTINEL_PORT
- 普通Redis使用redis.c/redisCommandTable作为服务器的命令表，Sentinel使用sentinel.c/sentinelcmds作为服务器的命令表

### 16.1.3 初始化Sentinel状态
- 服务器会初始化一个sentinel.c/sentinelState结构，dict *masters键为主服务器的名字，值为指向sentinelRedisInstance结构的指针

### 16.1.4 初始化Sentinel状态的masters属性
- 每个sentinelRedisInstance代表一个被Sentinel监视的Redis服务器实例，这个实例可以是主服务器、从服务器或者另外一个Sentinel

### 16.1.5 创建连向主服务器的网络连接
- Sentinel将成为主服务器的客户端，它可以向主服务器发送命令，并从命令回复中获取相关的信息
- 对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向主服务器的异步网络连接
  1. 一个是命令连接，这个链接专门用于向主服务器发送命令，接收命令回复
  2. 另一个是订阅连接，这个链接专门用于订阅主服务器的__sentinel__:hello频道

## 16.2 获取主服务器信息
- Sentinel默认10s向主服务器发送INFO指令，然后分析返回的信息
- INFO回复的信息，可以获取两方面：
  1. 关于主服务器本身的信息，包括run_id域记录的服务器运行ID，以及role域记录的服务器角色
  2. 主服务器下所有从服务器信息

## 16.3 获取从服务器信息
- 当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会将这个新的服务器创建相应的实例结构之外，Sentinel还会创建连接到从服务器的命令连接和订阅连接
- 创建连接后，Sentinel会在默认情况下，10s频率向从服务器发送INFO命令，会提取以下信息：
  1. 从服务器的运行ID run_id
  2. 从服务器的角色role
  3. 主服务器的IP地址master_host，以及主服务器的端口号master_port
  4. 主服务器的连接状态master_link_status
  5. 从服务器的优先级slave_priority
  6. 从服务器的复制偏移量slave_repl_offset

## 16.4 向主服务器和从服务器发送信息
- Sentinel会以每两秒一次频率，通过命令连接向所有被监视的主服务器和从服务器发送命令：PUBLISH __sentinel__:hello "<s_ip>,<s_port>,<s_runid>,<s_epoch>,<m_name>,<m_ip>,<m_port>,<m_epoch>"
- m_开头的参数记录为主服务器的信息，如果正在监视从服务器，那么就是从服务器正在复制的主服务器信息

## 16.5 接收来自主服务器和从服务器的频道信息
- 当建立起订阅连接后，向服务器发送SUBSCRIBE __sentinel__:hello，对__sentinel__:hello的订阅会一直持续到Sentinel与服务器连接断开为止
- 当一个Sentinel从__sentinel__:hello频道收到一条信息时，Sentinel会对这条信息进行解析，提取出信息中的Sentinel IP地址、Sentinel端口号、Sentinel运行ID等八个参数，用于检查：
  1. 如果信息中记录的Sentinel运行ID和接收的Sentinel的运行ID相同，那么说明这条消息是Sentinel自己发送的，Sentinel将丢弃这条消息，不做进一步处理
  2. 如果信心中记录的Sentinel运行ID和接收信息的Sentinel的运行ID不相同，那么说明这条信息是监视同一服务器的其他Sentinel发来的，接收信息的Sentinel将根据信息中的各个参数，对相应主服务器的实例结构进行更新

### 16.5.1 更新sentinels字典
- Sentinel为主服务器的实例结构中的sentinels字典保存了除Sentinel本身之外，所有同样监视这个主服务器的其他Sentinel的资料

### 16.5.2 创建连向其他Sentinel的命令连接
- 当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典创建相应的实例结构，还会创建一个连向新Sentinel的命令连接，而新Sentinel也会同样创建连向这个Sentinel的命令连接
- 使用命令连接相连的各个Sentinel可以通过向其他Sentinel发送命令请求来进行信息交换，可以实现主观下线检测和客观下线检测
- Sentinel之间不会创建订阅连接

## 16.6 检测主观下线状态
- 实例对PING命令回复可以分为两种情况
  1. 有效回复：实例返回+PONG、-LOADING、-MASTERDOWN三种回复
  2. 无效回复：除了以上其他的回复都是无效回复
- Sentinel配置爱文件中的down-after-milliseconds指定了Sentinel判断实例进入主观下线所需的时间长度

## 16.7 检查客观下线状态
- 当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线，它会同样监视这一主服务器的其他Sentinel进行询问，当Sentinel从其他Sentinel那里接收到足够数量的已下线判断后，Sentinel就会将从服务器判定为客观下线，并对主服务器执行故障转移操作

### 16.7.1 发送SENTINEL is-master-down-by-addr命令
- SENTINEL is-master-down-by-addr <ip> <port> <current_epoch> <runid>

### 16.7.2 接收SENTINEL is-master-down-by-addr命令
- 根据发来的命令参数，检查主服务器是否下线，然后向源Sentinel返回一条包含三个参数的Multi Bulk回复
- <down_state>: 返回目标Sentinel对主服务器的检查结果，1代表下线，0代表未下线
- <leader_runid>: *代表命令仅仅用于检测主服务器的下线状态，局部领头Sentinel的运行ID则用于选举领头Sentinel
- <leader_epoch>: 目标Sentinel的局部领头Sentinel的配置纪元，用于选举领头Sentinel。仅在leader_runid不为*的时候有效

### 16.7.3 接收SENTINEL is-master-down-by-addr命令的回复
- 当收到其他Sentinel同意主服务器已下线的数量，数量达到配置指定的判断可高管下线所需的数量时，Seentinel会将主服务器实例结构flags属性的SRI_O_DOWN标识打开，表示主服务器已经进入了客观下线状态

## 16.8 选举领头Sentinel
- 当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会协商，选举一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作。

## 16.9 故障转移
- 在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器
- 让已下线主服务器属下的所有从服务器改为复制新的主服务器
- 将已下线主服务器设置为新的主服务器的从服务器，当这个旧的服务器重新上线时，它就会成为新的主服务器的从服务器

### 16.9.1 选举新的主服务器
- 在已下线主服务器的属下的所有从服务器中，挑选一个状态良好、数据完整的从服务器，然后向这个从服务器发送SLAVEOF no one命令，将这个从服务器转换成主服务器

### 16.9.2 修改从服务器的复制目标
- 领头Sentinel向已下线主服务器server1的两个从服务器server3和server4发送SLAVEOF命令，让它们复制新的主服务器server2

### 16.9.3 将旧的主服务器变为从服务器
- 将已下线的主服务器设置为新的主服务器的从服务器，因为旧的主服务器已下线，所以这种设置是保存在server1对应的实例结构里面的，当server1重新上线时，Sentinel就会向它发送SLAVEOF命令，让它成为server2的从服务器

# 第17章 集群
## 17.1 节点
- 一个Redis集群通常由多个节点组成，在刚开始的时候，每个节点都是相互独立的
- 连接各个节点的工作可以使用CLUSTER MEET命令完成，CLUSTER MEET <ip> <port>
- 使用CLUSTER NODES可以看节点的集群

### 17.1.1 启动节点
- 一个节点就是一个运行在集群模式下的Redis服务器，cluster-enabled为yes开启服务器的集群模式
- 节点处理serverCron的时候会调用clusterCron函数

### 17.1.2 集群数据结构
- clusterNode结构保存了一个节点的当前状态，比如节点的创建时间、节点的名字、节点当前的配置纪元、节点的IP地址和端口号等等
- 每个节点都会使用一个clusterNode结构来记录自己的状态，并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的clusterNode结构，以此来记录其他节点状态
- clusterNode结构的link属性是一个clusterLink结构，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区
- redisClient和clusterLink结构都有自己的套接字描述符和输入、输出缓冲区，区别在于redisClient连接客户端的，clusterLink用于连接节点的
- 每个节点都保存着一个clusterState结构，这个结构记录了当前节点的视角下，集群目前所处的状态，例如集群是在线还是下线，集群包含多少个节点，集群当前的配置纪元

### 17.1.3 CLUSTER MEET命令的实现
- 向节点A发送CLUSTER MEET <ip> <port>命令
- 节点A会为B创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面
- 节点A根据CLUSTER MEET给定的IP和端口号，向B发送一条MEET消息
- 如果一切顺利，B接收到到A的MEET消息，B为A创建一个clusterNode结构，并将该结构加到自己的clusterState.nodes字典里面
- 之后，B将向A节点发送一条PONG消息
- 节点A收到B的PONG说明发送MEET成功了
- 节点A想节点B发送一条PING命令
- B通过接收A返回的PING命令，知道刚发送的PONG消息A接收到了，握手完成
- 之后，A节点将B节点通过Gossip协议传播给集群中的其他节点，让其他节点也与B进行握手

## 17.2 槽指派
- Redis集群通过分片的方式保存数据库的键值对：集群的整个数据库被分为16384个槽，数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点都可以处理0个或最多16384个槽
- 通过向节点发送CLUSTER ADDSLOTS命令，我们可以将一个或多个槽指派给节点负责

### 17.2.1 记录节点的槽指派信息
- clusterNode结构的slots属性和numslot属性记录了节点负责处理哪些槽
- 如果slots数组在i上的二进制位为1，标识节点处理槽i，为0则不处理槽i
- numslots属性则记录节点负责处理的槽的数量

### 17.2.2 传播节点的槽指派信息
- 一个节点除了会将自己负责处理的槽记录在clusterNode结构的slots属性和numslots属性之外，它还会将自己的slots数组通过消息发送给集群的其他节点，以此来告知其他节点自己目前负责处理哪些槽
- 集群中的每个节点都会知道数据库中的16384个槽分别指派给了集群中的那些节点

### 17.2.3 记录集群所有槽的指派信息
- clusterState结构中的slots数组记录了集群所有16384个槽的指派信息
- slots数组包含16384个项，每个数组都是指向clusterNode结构的指针
- clusterNode的slots数组记录单节点的槽指派也是必要的，因为当程序需要将某个节点的槽指派发送给其他节点的时候，只需要将这个数组发送就可以了。

### 17.2.4 CLUSTER ADDSLOTS命令的实现
- 如果有哪怕一个槽被指派给了某个节点，那么返回错误
- 设置clusterState的slots[i]指针，设置clusterNode结构的slots数组

## 17.3 在集群中执行命令
- 当客户端向节点发送与数据库有关的命令时，接收命令的节点会计算出命令要处理的数据库建属于哪个槽，并检查这个槽是否派给了自己
  1. 如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令
  2. 如果键所在的槽没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向至正确的节点，并在此发送之前想要执行的命令

### 17.3.1 计算键属于哪个槽
- slot_number(key)函数计算键key属于哪个槽，CRC16(key)&16383，CRC16计算键key的CRC-16校验和
- 使用CLUSTER KEYSLOT <key>命令可以查看一个给定键属于哪个槽

### 17.3.2 判断槽是否由当前节点负责处理
- 当节点计算出键所属的槽i之后，节点就会检查自己在clusterState.slots数组中的项i，判断键所在的槽是否由自己负责
  1. 如果clusterState.slots[i]等于clusterState.myself，那么说明槽i由当前节点负责
  2. 如果不等于，会根据clusterState.slots[i]指向的clusterNode结构所记录的节点IP和端口号，向客户端返回MOVED错误，指向客户端转向至正在处理槽i的节点

### 17.3.3 MOVED错误
- MOVED的格式：MOVED <slot> <ip>:<port>
- 一个集群客户端通常会与集群中的多个节点创建套接字连接，而所谓的节点转向实际上就是换一个套接字来发送命令

### 17.3.4 节点数据库的实现
- 节点和单机服务器在数据库方面的一个区别是，节点只能使用0号数据库，而单机Redis服务器则没有这个限制
- 除了将键值对保存在数据库里面之外，节点还会用clusterState结构中的slots_to_keys跳跃表来保存槽和键之间的关系，分值是一个槽号，每个节点的成员都是一个数据库键
- 通过slots_to_keys可以方便地对属于某个或某些槽的所有数据库键进行批量操作，例如CLUSTER GETKEYSINSLOT <slot> <count>可以返回最多count个属于槽slot的数据库键

## 17.4 重新分片
- 重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点
- 重新分片是由集群管理软件redis-trib负责执行的，步骤如下：
  1. 对目标节点发送CLUSTER SETSLOT <slot> IMPORTING <source_id>命令，让目标节点准备好从源节点导入属于槽slot的键值对
  2. 对源节点发送CLUSTER SETSLOT <slot> MIGRATING <target_id>命令，让源节点准备好将属于槽slot的键值对迁移至目标节点
  3. 向源节点发送CLUSTER GETKEYSINSLOT <slot> <count>命令获取最多count个属于槽slot的键值对的键名
  4. 对于步骤3获取每个键名，都向源节点发送一个MIGRATE <target_ip> <target_port> <key_name> 0 <timeout>命令，将被选中的键原子地从源节点迁移至目标节点
  5. 重复执行步骤3和步骤4，直到源节点保存的所有属于槽slot的键值对都被迁移至目标节点为止
  6. redis-trib向集群中的任意一个节点发送CLUSTER SETSLOT <slot> NODE <target_id>命令，将槽slot指派给目标节点，这一指派消息会通过消息发送至整个集群
