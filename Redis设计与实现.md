# 前言
模块需要实现一个“共同关注”功能，用于计算两个用户关注了哪些共同的用户。关系数据库不能很好的支持，Redis的集合可以执行交集、并集、差集等操作

# 第1章 引言
如果想打算深入了解Redis实现原理的底层细节，本书在RedisBook.com提供了一份带有详细注释的Redis源码

## 1.1 Redis版本说明
本书是基于Redis 2.9 — 也即是Redis 3.0的开发版来编写的

## 1.2 章节安排

### 第一部分 ”数据结构与对象“
- 数据库键总是一个字符串对象
- 而数据库键值则可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象

### 第二部分 ”单机数据库的实现“
- 第9章 ”数据库“对Redis数据库的实现原理进行了介绍
- 第10章”RDB持久化“和第11章”AOF持久化“分别介绍了Redis两种不同的持久化方法的实现原理
- 第12章“事件”对Redis的文件事件和时间事件进行了介绍
- 第13章“客户端”对Redis服务器维护和管理客户端状态的方法进行了介绍
- 第14章“服务器”对单机Redis服务器的运行机制进行了介绍

### 第三部分 “多机数据库的实现”
- 第15章”复制"对Redis的主从复制功能的实现原理进行了介绍
- 第16章“Sentinel”对Redis Sentinel的实现原理进行了介绍
- 第17章“集群”对Redis集群的实现原理进行了介绍

### 第四部分 ”独立功能的实现“
- 第18章“发布与订阅”对PUBLISH、SUBSCRIBE、PUBSUB等命令的实现原理进行了介绍
- 第19章“事务”对MULTI、EXEC、WATCH等命令的实现原理进行了介绍
- 第20章“Lua脚本”对EVAL、EVALSHA、SCRIPT LOAD等命令的原理进行了介绍
- 第21章“排序”对SORT命令以及SORT命令所有可用选项的实现原理进行了介绍
- 第22章”二进制位数组“对Redis保存二进制位数组的方法进行了介绍
- 第23章”慢查询日志"对Redis创建和保存慢查询日志的方法进行了介绍
- 第24章“监视器”介绍了将客户端变为监视器的方法

## 1.3 推荐的阅读方法
第一部分和第二部分必读，第三部分是多机版应用部分，第四部分包含的各章是完全独立的

## 1.4 杭温规则
- 引用Redis源代码文件file中的名字name时，file/name
- 引用标准头文件file中的名字name，使用<file>/name
- 第一次引用某个名字之后，本书就会去掉名字前缀的文件名
- 本书使用struct.property格式来引用struct结构的porperty属性

## 1.5配套网站
redisbook.com记录了本书的最新消息，并且提供了附带详细注释的Redis源代码

# 第2章 简单动态字符串
- Redis没有用C字符串（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串（simple dynamic string, SDS）的抽象类型
- 客户端执行SET msg "hello world"，那么Redis将创建一个键值对，键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串"msg"的SDS，键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串"hello world"的SDS
- 客户端执行RPUSH fruits "apple" "banana" "cherry"，Redis将在数据库创建一个新的键值对，键值对的键是一个字符串对象，底层实现了一个保存字符串"fruits"的SDS，键值对的值是一个列表对象，列表对象的三个值分别由3个SDS实现
- SDS还用于AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区

## 2.1 SDS的定义
sdshdr的len记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度，free记录buf数组中未使用字节的数量，字节数组，用于保存字符串

## 2.2 SDS与C字符串的区别
C语言使用长度N+1的字符串来标识长度为N的字符串，字符串数组的最后一个元素总是空字符串'\0'

### 2.2.1 常数复杂度获取字符串长度
C语言字符串获取数组需要遍历，时间复杂度O(N)，Redis是O(1)

### 2.2.2 杜绝缓冲区溢出
因为C语言不记录自身长度，strcat假定dest会有足够多的内存，如果假定不成立，就会产生缓冲区溢出。Redis里面的sdscat检查空间不足，会先扩展空间，然后再执行拼接操作。

### 2.2.3 减少修改字符串时带来的内存重分配次数
C字符串如果append，需要重新分配内存，如果忘记则可能会产生缓冲区溢出。如果缩短字符串trim，需要释放字符串不使用的内存空间，否则会产生内存泄露。Redis通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略

### 2.2.4 二进制安全
C字符串中的字符必须符合某种编码（比如ASCII)，并且除了字符串的末位之外，字符串里面不能包含空字符串，否则最先被程序读入的空字符串将被认为是字符串结尾。SDS的API都是二进制安全的

### 2.2.5 兼容部分C字符串函数
Redis会重用C语言的函数

# 第3章 链表
除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，保存多个客户端状态信息，以及使用链表来构建客户端输出缓冲区

## 3.1 链表和链表节点的实现
- 每个链表节点使用一个adlist.h/listNode结构来表示，前置节点，后置节点，节点的值
- adlist.h/list来持有链表，包含了头指针head、表尾指针tail，以及链表长度计数器len，dup函数复制链表节点锁保存的值，free函数用于释放链表节点所保存的值，match对比链表节点所保存的值和另一个输入值是否相等。
- Redis的链表特征：双端，无环，带表头指针和表尾指针，带表长度计数器，多态

## 3.2 链表和链表节点的API
- listSetDupMethod，将给定的函数设置为链表的节点值复制函数
- listGetDupMethod：返回链表当前正在使用的节点值复制函数
...

# 第4章 字典
- 字典，又称符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构
- 键和值称为键值对
- 字典中的每个键都是独一无二的
- Redis数据库就是用字典作为底层实现的，字典还是哈希键的底层实现之一

## 4.1 字典的实现
Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对

### 4.1.1 哈希表
哈希表由dict.h/dictht结构定义

### 4.1.2 哈希表节点
哈希表节点使用dictEntry结构表示，每个dictEntry都保存着一个键值对。

### 4.1.3 字典
Redis中的字典由dict.h/dict结构表示，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。

## 4.2 哈希算法
当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

## 4.3 解决键冲突
当两个或以上数量的键被分配到了哈希数组的同一个索引上面时，我们称这些键发生了冲突。Redis哈希表使用链地址法来解决键冲突。next指针构成单向链表，因为没有尾指针，所以新元素总是插入到表头的位置

## 4.4 rehash
当哈希表保存的键值对数量太多或者太少时，程序需要rehash（重新散列），rehash的步骤
1. 为ht[1]分配空间，扩展的话ht[1]为第一个大于等于ht[0].used*2的2的n次方，收缩ht[1]的大小为第一个大于等于ht[0].used的2的n次方
2. 将保存在ht[0]的所有键值对rehash到ht[1]上面，重新计算键的哈希值和索引值
3. 当所有ht[0]已迁移到ht[1]，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表

哈希表的扩展与收缩
满足任意一个条件，程序会对哈希表进行扩展操作：
1. 服务器目前没有执行BGSAVE命令或者BGREWRITEAOF命令，哈希表负载因子大于等于1
2. 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，哈希表负载因子大于等于5

哈希表负载因子=ht[0].used/ht[0].size

当哈希表负载因子小于0.1，程序进行收缩操作

# 第5章 跳跃表
- 跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点指针，从而达到快速访问节点的目的。
- Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员(member)是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。
- Redis只有在两个地方用到跳跃表，一个是实现有序集合键，两一个是在集群节点中用作内部数据结构

## 5.1 跳跃表的实现
- 跳跃表由redis.h/zskiplistNode表示跳跃列表节点和redis.h/zskiplist保存跳跃表节点的相关信息，比如节点数量，以及指向表头节点和表尾节点指针等
- ziplist结构：header表头，tail表尾，level层数最大的那个节点层数，length节点数量
- zskiplistNode结构：level层，层带有前进指针和跨度，backward后退指针，score分值，obj成员对象

# 第6章 整数集合
整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。

## 6.1 整数集合的实现
- intset.h/intset标识一个数据集合，contents是数组集合的底层实现：整数集合的每个元素都是contents数组的一个数据项，各个项在数组中按照值的大小从小到大有序地排列，并且数组不包含任何重复项
- length记录了整数集合包含的元素数量，也是contents数组的长度
- contents数组真正的类型取决于encoding属性的值

## 6.2 升级
升级集合并添加新元素首先根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。将底层数组现有所有元素转化成新元素相同类型，并将类型转化后的元素放置到正确位置上。将新元素添加到底层数组里面

## 6.3 升级的好处
一个是提升整数集合的灵活性，另一个是尽可能地节约内存

### 6.3.1 提升灵活性
C语言只能添加对应类型到数组里面，Redis的集合整数不用担心出现类型错误

### 6.3.2 节约内存
如果我们一直向整数集合添加int16_t，集合的底层就会一直是int16_t类型整数

## 6.4 降级
集合整数不支持降级操作

# 第7章 压缩列表
压缩列表（ziplist）是列表键和哈希键的底层实现之一。列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串。

## 7.1 压缩列表的构成
- 压缩列表是为了节约内存而开发的，由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值
- zlbytes记录整个压缩列表占用的内存字节数，zltail记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，zllen记录了压缩列表包含的节点数量，entryX压缩列表包含的各个节点，节点的长度由节点保存的内容而定，zlend用来标记压缩列表的尾端

## 7.2 压缩列表节点的构成
- 每个压缩节点可以保存一个字节数组或者一个整数值
- 每个压缩列表节点都由previous_entry_length、encoding、content三个部分构成

### 7.2.1 previous_entry_length
以字节为单位，记录了压缩列表中前一个节点的长度。长度可以是1字节或者5字节

### 7.2.2 encoding
记录节点的content属性所保存数据的类型和长度

### 7.2.3 content
保存节点的值

## 7.3 连锁更新
previous_entry_length1字节到5字节的变化，可能导致添加和删除都可能产生连锁更新，连锁更新最坏复杂度为o(n2)，因为概率低，实际ziplistPush的平均复杂度为o(n)

# 第8章 对象
Redis并没有使用之前讲的数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统

## 8.1 对象的类型与编码
- 每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）
- Redis中每个对象都由一个redisObject结构表示，type类型，encoding编码，ptr指向底层实现数据结构的指针

### 8.1.1 类型
- type可以是REDIS_STRING字符串对象，REDIS_LIST列表对象，REDIS_HASH哈希对象，REDIS_SET集合对象，REDIS_ZSET有序集合对象
- TYPE命令可以看值的对象类型

### 8.1.2 编码和底层实现
- ptr指向对象的底层实现数据结构，数据结构由对象的encoding决定
- 使用OBJECT ENCODING可以查看数据库键的值对象的编码
- 每种类型的对象都至少使用了两种不同的编码
- 整数：int，embstr编码的简单动态字符串：embstr，简单动态字符串：raw，字典：hashtable，双端链表：linkedlist，压缩列表：ziplist，整数集合：intset，跳跃表和字典：skiplist

## 8.2 字符串对象
- 字符串的UI想的编码可以是int、raw或者embstr
- 如果一个字符串保存的是整数值，并且可以用long类型表示，则会使用编码int
- 如果字符串对象保存的是一个字符串值，并且长度大于39字节，那么使用一个简单动态字符串（SDS）保存这个字符串值，编码设置为raw
- 如果字符串保存的是一个字符串值，并且字符串长度小于39字节，编码为embstr。embstr编码所需内存分配次数从raw的两次变1次，释放内存只需要1次，所有的数据都在一块连续的内存里面，能更好的利用缓存带来的优势。
- long double表示的浮点数在redis里面是作为字符串值来保存的

### 8.2.1 编码的转换
- int编码执行一些命令，对象存的不再是整数值，而是一个字符串，则字符串编码从int变为raw
- embstr在任何修改命令，都会编码变成raw

### 8.2.2 字符串命令的实现
SET，GET，APPEND，INCRBYFLOAT，INCRBY，DECRBY，STRLEN，SETRANGE，GETRANGE

## 8.3 列表对象
- 列表对象编码可以是ziplist或者linkedlist
- ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素。
- RPUSH命令
- linkedlist编码的列表使用双端链表作为底层实现，底层的双端链表结构中包含了字符串对象
- 字符串对象是Redis五中类型的对象中唯一一种会被其他四种对象嵌套的对象

### 8.3.1 编码转换
当列表对象满足一下两个条件，编码使用ziplist，不满足则使用linkedlist
- 列表对象保存到 所有字符串元素长度小于64字节
- 列表对象保存的元素数量小512个

### 8.3.2 列表命令的实现
LPUSH，RRPUSH，LPOP，RPOP，LINDEX，LLEN，LINSERT，LREM，LTRIM，LSET

## 8.4 哈希对象
- 哈希对象的编码可以是ziplist或者hashtable
- ziplist编码的哈希对象使用压缩列表作为底层实现，保存了同一键值对的两个节点总是紧挨着一起，保存键的节点在前，保存值的节点在后。先添加到哈希对象的键值对会被放在压缩列表的表头方向，后添加的被放在压缩列表的表尾方向。
- HSET命令
- hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存，字典的每个键都是一个字符串对象，对象中保存了键值对的键，字典的每个值都是一个字符串对象，对象中保存了键值对的值。

### 8.4.1 编码转换
当哈希对象可以同时满足两个一下条件，则使用ziplist编码。否则使用hashtable
- 哈希对象保存的所有键值对的键和值字符串长度都小于64字节
- 哈希对象保存的键值对数量小于512

### 8.4.2 哈希命令的实现
HSET，HGET，HEXISTS，HDEL，HLEN，HGETALL

## 8.5 集合对象
- 集合对象的编码可以是intset或者hashtable
- intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面
- hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则设为NULL
- SADD指令

### 8.5.1 编码的转换
当集合对相关同时满足以下两个条件，对象使用intset编码，不满足则使用hashtable
- 集合对象保存的所有元素都是整数值
- 集合对象保存的元素数量不超过512个

### 8.5.2 集合命令的实现
SADD，SCARD，SISMEMBER，SMEMBERS，SRANDMEMBER，SPOP，SREM

## 8.6 有序集合对象
- 有序集合的编码可以是ziplist或者skiplist
- ziplist编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个保存元素的分值。分数低的在表头，分数高的在表尾
- ZADD指令
- skiplist编码的有序集合列表使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表。zset中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点保存了一个集合元素。跳跃表节点object属性保存了元素的成员，节点score属性保存了分值。zset结构中的dict字典为有序集合创建了一个从成员到分数的映射。
- 有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是double。两种数据结构都会使用指针共享相同元素的成员和分值。

### 8.6.1 编码的转换
当有序集合对象可以同时满足以下两个条件，使用ziplist，否则使用skiplist
- 有序集合保存的元素数量小于128个
- 有序集合保存的所有元素成员的长度都小于64字节

### 8.6.2 有序集合命令的实现
ZADD，ZCARD，ZCOUNT，ZRANGE，ZREVRANGE，ZRANK，ZREEM，ZSCORE

## 8.7 类型检查与命令多态
- 对任何键都可以执行：DEL、EXPIRE、RENAME、TYPE、OBJECT
- SET、GET、APPEND、STRLEN只能对字符串键执行
- HDEL、HSET、HGET、LEN只能对哈希键执行
- RPUSH、LPOP、LINSERT、LLEN只能对列表建
- SADD、SPOP、SINTER、SCARD只能对集合键执行
- ZADD、ZCARD、ZRANK、ZSCORE只能对有序集合键执行

### 8.7.1 类型检查的实现
举个例子：客户端发送LLEN <key>命令，服务器检查键key的值对象是否列表对象，是则对键key执行LLEN命令，否则返回一个类型错误。

### 8.7.2 多态命令的实现
我们可以认为LEN命令是多态的，只要执行LLEN命令的是列表键，那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都能正常运行。

## 8.8 内存回收
- C语言并不具备自动回收功能，Redis在自己的对象系统中构建了一个引用计数技术实现内存回收机制。redisObject的refcount属性
- 创建一个新对象，refcount为1，被一个应用程序使用则加1，不再被程序使用则减1，引用值变为0，对象所占用内存会被释放

## 8.9 对象共享
- 让多个键共享同一个值对象需要执行两个步骤：将数据库键的值指针指向一个现有的值对象；将被共享的值对象的引用计数加1.
- 目前来说，Redis会在初始化服务器时，创建一万个字符串的UI想，这些对象包含了从1-9999的所有整数值，当服务器需要到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。
- 为什么Redis不共享包含字符串的对象？共享对象时保存整数的字符串对象，验证操作O(1)，共享对象是字符串值的字符串对象，验证复杂度O(N)，包含了多个值（或者对象）的对象，比如列表对象或者哈希对象，验证复杂度O(n2)，尽管共享更复杂的对象可以节约更多的内存，但受到CPU时间的限制，Redis只对包含整数值的字符串对象进行共享。

## 8.10 对象的空转时长
除了type，encoding，ptr和refcount四个属性外，redisObject结构包含的最后一个属性为lru属性，改属性记录了对象最后一次被命令程序访问的时间。OBJECT IDLETTIME可以打印出给定键的空转时长，空转时长就是当前时间减去键值对象lru时间计算得出的。

# 第9章 数据库

## 9.1 服务器中的数据库
Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库。Redis默认创建16个数据库

## 9.2 切换数据库
客户端可以通过执行SELECT命令来切换目标数据库。redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针。客户端切换可能忘记当前使用哪个数据库，所以当执行FLUSHDB这样危险命令之前，最好先执行一个SELECT命令，显式地切换到指定的数据库，然后再执行别的命令。

## 9.3 数据库键空间
- Redis是一个键值对数据库服务器，服务器中的每个数据库都是由一个redis.h/redisDb结构表示，其中redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间。
- 键空间的键也就是数据库中的键，每个键都是一个字符串对象
- 键空间的值也就是数据库的值，可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。

### 9.3.1 添加新键
添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象

### 9.3.2 删除键
删除数据库中的一个键，实际上就是在键空间里面删除键锁对应的键值对对象

### 9.3.3 更新键
对一个数据库键进行更新，实际上是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。

### 9.3.4 对键取值
对一个数据库键进行取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同

### 9.3.5 其他键空间操作
清空整个数据库FLUSHDB命令、随机返回数据库中某个键的RANDOMKEY命令、返回数据库键数量DBSIZE命令、EXISTS、RENAME、KEYS都是通过键空间进行操作来实现的。

### 9.3.6 读写键空间时的维护操作
当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作，例如
- 读取一个键后（读操作或者写操作都要对键进行读取），服务器会根据键是否存在来更新服务器键空间中（hit）次数或键空间不命中（miss）次数，这两个值在INFO stats命令的keyspace_hits和keyspace_misses查看
- 读取一个键后，服务器会更新LRU时间，OBJECT idletime <key>查看
- 读取一个键后，发现键已经过期，会先删除这个键再执行其他操作
- 如果客户端WATCH命令监听了某个键，那么服务器对监视的键进行修改，会将这个键标记为脏（dirty），从而事务知道被修改过
- 服务器每次修改一个键后，都会对脏（dirty）加1，这个计数器会出发服务器的持久化以及复制
- 如果服务器开启了数据库通知功能，那么键修改后会按照配置发送响应的数据库通知

## 9.4 设置键的生存时间或过期时间
通过EXPIRE命令或者PEXPIRE命令可以以秒或者毫秒为数据库的某个键设置生存时间。通过EXPIREAT命令或者PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间。TTL命令和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余时间。

### 9.4.1 设置过期时间
EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的

### 9.4.2 保存过期时间
redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个为过期字典：
- 过期字典的键是一个指针，这个指针指向键空间中的某个键对象
- 过期字典的值是一个long类型的整数，保存了键所指向数据库的过期时间，一个毫秒精度的UNIX时间戳

### 9.4.3 移出过期时间
PERSIST命令可以移出一个键的过期时间

### 9.4.4 计算并返回剩余生存时间
TTL命令个以秒为单位返回剩余时间，PTTL返回毫秒的剩余生存时间。都是计算键的过期时间和当前之间的差值来实现的。

### 9.4.5 过期键的判定
- 检查给定键是否存在过期字典，如果存在取出键的过期时间
- 检查当前UNIX时间戳是否大于键的过期时间，如果是那么键过期，否则键未过期

## 9.5 过期键删除策略

### 9.5.1 定时删除
- 定期删除通过定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用内存
- 缺点是，对CPU时间不友好，在过期键比较多的时候，删除的时候会占用一部分CPU时间，对吞吐量和响应时间造成影响

### 9.5.2 惰性删除
- 程序只会在取出键对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行
- 缺点是对内存不友好，如果一个键过期，而这个键又仍保留在内存中。
- 如果永远不访问键，则永远不会被删除（除非用户手动执行FLUSHDB），可以称为一种内存泄露

### 9.5.3 定期删除
- 每隔一段时间执行一次删除过期操作，并通过限制删除执行的时长和频率来减少删除操作对CPU时间的影响
- 通过定期删除过期键，有效的减少了因为过期键而带来的内存浪费

## 9.6 Redis的过期键删除策略
Redis使用惰性删除和定期删除两种策略

### 9.6.1 惰性删除策略的实现
- 惰性删除策略在db.c/expireIfNeeded函数实现，所有读写都会调用expireIfNeeded函数进行检查
- 每个命令都应该能处理当键存在和不存在的情况

### 9.6.2 定期删除策略的实现
定期删除策略由redis.c/activeExpireCycle函数实现，每当Redis的服务器周期性操作recdis.c/serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机一部分键的过期时间，并删除其中的过期键。

## 9.7 AOF、RDB和复制功能对过期键的处理

### 9.7.1 生成RDB文件
在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中

### 9.7.2 载入RDB文件
启动Redis的时候，如果开启了RDB，将载入RDB文件
- 如果服务器以主服务器模式运行，程序会对文件中保存的键进行检查，过期的则被忽略
- 如果服务器以从服务器模式运行，不论是否过期，都会载入到数据库中。主从同步的时候，从服务器的过期数据会被删掉

### 9.7.3 AOF文件写入
当服务器以AOF持久化模式运行时，如果服务器中的某个键已经过期，但它还没来得及惰性删除或者定期删除，那么AOF文件不会因为这个键过期而产生任何影响。因为在删除的时候程序会追加一条命令，来显示地记录该键被删除。

### 9.7.4 AOF重写
在执行AOF重写的时候，程序会对数据库中的键进行检查，已经过期的键不会被保存到重写后的AOF文件中。

### 9.7.5 复制
当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：
- 主服务器在删除一个过期键之后，会显示地向所有的从服务器返送一个DEL命令，告知从服务器删除这个过期键
- 从服务器在执行客户端命令时，即使碰到过期键也不会将过期键删除，而是像处理未过期键一样处理过期键
- 从服务器只有在接收到主服务器发来的DEL命令之后，才会删除过期键

## 9.8 数据库通知
- 数据库通知可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。
- 这一类关注“某个键执行了什么命令”的通知称之为键空间通知
- 另一类成为键事件通知，它们关注的是”某个命令被什么键执行了”

### 9.8.1 发送通知
- 由notify.c/notifyKeyspaceEvent函数实现
- type是当前想发送的通知的类型，event、keys和dbid分别是事件的名称、产生的事件的键、以及产生事件的数据库号码

### 9.8.2 发送通知的实现
pubsubPublishMessage函数是PUBLISH命令的实现函数，执行这个函数等同于执行PUBLISH命令，订阅数据库通知的客户端收到的信息就是由这个函数发出的。

# 第10章 RDB持久化
