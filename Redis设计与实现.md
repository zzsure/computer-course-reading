# 前言
模块需要实现一个“共同关注”功能，用于计算两个用户关注了哪些共同的用户。关系数据库不能很好的支持，Redis的集合可以执行交集、并集、差集等操作

# 第1章 引言
如果想打算深入了解Redis实现原理的底层细节，本书在RedisBook.com提供了一份带有详细注释的Redis源码

## 1.1 Redis版本说明
本书是基于Redis 2.9 — 也即是Redis 3.0的开发版来编写的

## 1.2 章节安排

### 第一部分 ”数据结构与对象“
- 数据库键总是一个字符串对象
- 而数据库键值则可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象

### 第二部分 ”单机数据库的实现“
- 第9章 ”数据库“对Redis数据库的实现原理进行了介绍
- 第10章”RDB持久化“和第11章”AOF持久化“分别介绍了Redis两种不同的持久化方法的实现原理
- 第12章“事件”对Redis的文件事件和时间事件进行了介绍
- 第13章“客户端”对Redis服务器维护和管理客户端状态的方法进行了介绍
- 第14章“服务器”对单机Redis服务器的运行机制进行了介绍

### 第三部分 “多机数据库的实现”
- 第15章”复制"对Redis的主从复制功能的实现原理进行了介绍
- 第16章“Sentinel”对Redis Sentinel的实现原理进行了介绍
- 第17章“集群”对Redis集群的实现原理进行了介绍

### 第四部分 ”独立功能的实现“
- 第18章“发布与订阅”对PUBLISH、SUBSCRIBE、PUBSUB等命令的实现原理进行了介绍
- 第19章“事务”对MULTI、EXEC、WATCH等命令的实现原理进行了介绍
- 第20章“Lua脚本”对EVAL、EVALSHA、SCRIPT LOAD等命令的原理进行了介绍
- 第21章“排序”对SORT命令以及SORT命令所有可用选项的实现原理进行了介绍
- 第22章”二进制位数组“对Redis保存二进制位数组的方法进行了介绍
- 第23章”慢查询日志"对Redis创建和保存慢查询日志的方法进行了介绍
- 第24章“监视器”介绍了将客户端变为监视器的方法

## 1.3 推荐的阅读方法
第一部分和第二部分必读，第三部分是多机版应用部分，第四部分包含的各章是完全独立的

## 1.4 杭温规则
- 引用Redis源代码文件file中的名字name时，file/name
- 引用标准头文件file中的名字name，使用<file>/name
- 第一次引用某个名字之后，本书就会去掉名字前缀的文件名
- 本书使用struct.property格式来引用struct结构的porperty属性

## 1.5配套网站
redisbook.com记录了本书的最新消息，并且提供了附带详细注释的Redis源代码

# 第2章 简单动态字符串
- Redis没有用C字符串（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串（simple dynamic string, SDS）的抽象类型
- 客户端执行SET msg "hello world"，那么Redis将创建一个键值对，键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串"msg"的SDS，键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串"hello world"的SDS
- 客户端执行RPUSH fruits "apple" "banana" "cherry"，Redis将在数据库创建一个新的键值对，键值对的键是一个字符串对象，底层实现了一个保存字符串"fruits"的SDS，键值对的值是一个列表对象，列表对象的三个值分别由3个SDS实现
- SDS还用于AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区

## 2.1 SDS的定义
sdshdr的len记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度，free记录buf数组中未使用字节的数量，字节数组，用于保存字符串

## 2.2 SDS与C字符串的区别
C语言使用长度N+1的字符串来标识长度为N的字符串，字符串数组的最后一个元素总是空字符串'\0'

### 2.2.1 常数复杂度获取字符串长度
C语言字符串获取数组需要遍历，时间复杂度O(N)，Redis是O(1)

### 2.2.2 杜绝缓冲区溢出
因为C语言不记录自身长度，strcat假定dest会有足够多的内存，如果假定不成立，就会产生缓冲区溢出。Redis里面的sdscat检查空间不足，会先扩展空间，然后再执行拼接操作。

### 2.2.3 减少修改字符串时带来的内存重分配次数
C字符串如果append，需要重新分配内存，如果忘记则可能会产生缓冲区溢出。如果缩短字符串trim，需要释放字符串不使用的内存空间，否则会产生内存泄露。Redis通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略

### 2.2.4 二进制安全
C字符串中的字符必须符合某种编码（比如ASCII)，并且除了字符串的末位之外，字符串里面不能包含空字符串，否则最先被程序读入的空字符串将被认为是字符串结尾。SDS的API都是二进制安全的

### 2.2.5 兼容部分C字符串函数
Redis会重用C语言的函数

# 第3章 链表
除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，保存多个客户端状态信息，以及使用链表来构建客户端输出缓冲区

## 3.1 链表和链表节点的实现
- 每个链表节点使用一个adlist.h/listNode结构来表示，前置节点，后置节点，节点的值
- adlist.h/list来持有链表，包含了头指针head、表尾指针tail，以及链表长度计数器len，dup函数复制链表节点锁保存的值，free函数用于释放链表节点所保存的值，match对比链表节点所保存的值和另一个输入值是否相等。
- Redis的链表特征：双端，无环，带表头指针和表尾指针，带表长度计数器，多态

## 3.2 链表和链表节点的API
- listSetDupMethod，将给定的函数设置为链表的节点值复制函数
- listGetDupMethod：返回链表当前正在使用的节点值复制函数
...

# 第4章 字典
- 字典，又称符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构
- 键和值称为键值对
- 字典中的每个键都是独一无二的
- Redis数据库就是用字典作为底层实现的，字典还是哈希键的底层实现之一

## 4.1 字典的实现
Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对

### 4.1.1 哈希表
哈希表由dict.h/dictht结构定义

### 4.1.2 哈希表节点
哈希表节点使用dictEntry结构表示，每个dictEntry都保存着一个键值对。

### 4.1.3 字典
Redis中的字典由dict.h/dict结构表示，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。

## 4.2 哈希算法
当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

## 4.3 解决键冲突
当两个或以上数量的键被分配到了哈希数组的同一个索引上面时，我们称这些键发生了冲突。Redis哈希表使用链地址法来解决键冲突。next指针构成单向链表，因为没有尾指针，所以新元素总是插入到表头的位置

## 4.4 rehash
当哈希表保存的键值对数量太多或者太少时，程序需要rehash（重新散列），rehash的步骤
1. 为ht[1]分配空间，扩展的话ht[1]为第一个大于等于ht[0].used*2的2的n次方，收缩ht[1]的大小为第一个大于等于ht[0].used的2的n次方
2. 将保存在ht[0]的所有键值对rehash到ht[1]上面，重新计算键的哈希值和索引值
3. 当所有ht[0]已迁移到ht[1]，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表

哈希表的扩展与收缩
满足任意一个条件，程序会对哈希表进行扩展操作：
1. 服务器目前没有执行BGSAVE命令或者BGREWRITEAOF命令，哈希表负载因子大于等于1
2. 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，哈希表负载因子大于等于5

哈希表负载因子=ht[0].used/ht[0].size

当哈希表负载因子小于0.1，程序进行收缩操作

# 第5章 跳跃表
- 跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点指针，从而达到快速访问节点的目的。
- Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员(member)是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。
- Redis只有在两个地方用到跳跃表，一个是实现有序集合键，两一个是在集群节点中用作内部数据结构

## 5.1 跳跃表的实现
- 跳跃表由redis.h/zskiplistNode表示跳跃列表节点和redis.h/zskiplist保存跳跃表节点的相关信息，比如节点数量，以及指向表头节点和表尾节点指针等
- ziplist结构：header表头，tail表尾，level层数最大的那个节点层数，length节点数量
- zskiplistNode结构：level层，层带有前进指针和跨度，backward后退指针，score分值，obj成员对象

# 第6章 整数集合
整数集合(intset)是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。

## 6.1 整数集合的实现
- intset.h/intset标识一个数据集合，contents是数组集合的底层实现：整数集合的每个元素都是contents数组的一个数据项，各个项在数组中按照值的大小从小到大有序地排列，并且数组不包含任何重复项
- length记录了整数集合包含的元素数量，也是contents数组的长度
- contents数组真正的类型取决于encoding属性的值

## 6.2 升级
升级集合并添加新元素首先根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。将底层数组现有所有元素转化成新元素相同类型，并将类型转化后的元素放置到正确位置上。将新元素添加到底层数组里面

## 6.3 升级的好处
一个是提升整数集合的灵活性，另一个是尽可能地节约内存

### 6.3.1 提升灵活性
C语言只能添加对应类型到数组里面，Redis的集合整数不用担心出现类型错误

### 6.3.2 节约内存
如果我们一直向整数集合添加int16_t，集合的底层就会一直是int16_t类型整数

## 6.4 降级
集合整数不支持降级操作

# 第7章 压缩列表
压缩列表（ziplist）是列表键和哈希键的底层实现之一。列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串。

## 7.1 压缩列表的构成
- 压缩列表是为了节约内存而开发的，由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值
- zlbytes记录整个压缩列表占用的内存字节数，zltail记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，zllen记录了压缩列表包含的节点数量，entryX压缩列表包含的各个节点，节点的长度由节点保存的内容而定，zlend用来标记压缩列表的尾端

## 7.2 压缩列表节点的构成
- 每个压缩节点可以保存一个字节数组或者一个整数值
- 每个压缩列表节点都由previous_entry_length、encoding、content三个部分构成

### 7.2.1 previous_entry_length
以字节为单位，记录了压缩列表中前一个节点的长度。长度可以是1字节或者5字节

### 7.2.2 encoding
记录节点的content属性所保存数据的类型和长度

### 7.2.3 content
保存节点的值

## 7.3 连锁更新
previous_entry_length1字节到5字节的变化，可能导致添加和删除都可能产生连锁更新，连锁更新最坏复杂度为o(n2)，因为概率低，实际ziplistPush的平均复杂度为o(n)

# 第8章 对象
Redis并没有使用之前讲的数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统

## 8.1 对象的类型与编码
- 每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）
- Redis中每个对象都由一个redisObject结构表示，type类型，encoding编码，ptr指向底层实现数据结构的指针

### 8.1.1 类型
- type可以是REDIS_STRING字符串对象，REDIS_LIST列表对象，REDIS_HASH哈希对象，REDIS_SET集合对象，REDIS_ZSET有序集合对象
- TYPE命令可以看值的对象类型

### 8.1.2 编码和底层实现
- ptr指向对象的底层实现数据结构，数据结构由对象的encoding决定
- 使用OBJECT ENCODING可以查看数据库键的值对象的编码
- 每种类型的对象都至少使用了两种不同的编码
- 整数：int，embstr编码的简单动态字符串：embstr，简单动态字符串：raw，字典：hashtable，双端链表：linkedlist，压缩列表：ziplist，整数集合：intset，跳跃表和字典：skiplist

## 8.2 字符串对象
- 字符串的UI想的编码可以是int、raw或者embstr
- 如果一个字符串保存的是整数值，并且可以用long类型表示，则会使用编码int
- 如果字符串对象保存的是一个字符串值，并且长度大于39字节，那么使用一个简单动态字符串（SDS）保存这个字符串值，编码设置为raw
- 如果字符串保存的是一个字符串值，并且字符串长度小于39字节，编码为embstr。embstr编码所需内存分配次数从raw的两次变1次，释放内存只需要1次，所有的数据都在一块连续的内存里面，能更好的利用缓存带来的优势。
- long double表示的浮点数在redis里面是作为字符串值来保存的

### 8.2.1 编码的转换
- int编码执行一些命令，对象存的不再是整数值，而是一个字符串，则字符串编码从int变为raw
- embstr在任何修改命令，都会编码变成raw

### 8.2.2 字符串命令的实现
SET，GET，APPEND，INCRBYFLOAT，INCRBY，DECRBY，STRLEN，SETRANGE，GETRANGE

## 8.3 列表对象
- 列表对象编码可以是ziplist或者linkedlist
- ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素。
- RPUSH命令
- linkedlist编码的列表使用双端链表作为底层实现，底层的双端链表结构中包含了字符串对象
- 字符串对象是Redis五中类型的对象中唯一一种会被其他四种对象嵌套的对象

### 8.3.1 编码转换
当列表对象满足一下两个条件，编码使用ziplist，不满足则使用linkedlist
- 列表对象保存到 所有字符串元素长度小于64字节
- 列表对象保存的元素数量小512个

### 8.3.2 列表命令的实现
LPUSH，RRPUSH，LPOP，RPOP，LINDEX，LLEN，LINSERT，LREM，LTRIM，LSET

## 8.4 哈希对象
- 哈希对象的编码可以是ziplist或者hashtable
- ziplist编码的哈希对象使用压缩列表作为底层实现，保存了同一键值对的两个节点总是紧挨着一起，保存键的节点在前，保存值的节点在后。先添加到哈希对象的键值对会被放在压缩列表的表头方向，后添加的被放在压缩列表的表尾方向。
- HSET命令
- hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存，字典的每个键都是一个字符串对象，对象中保存了键值对的键，字典的每个值都是一个字符串对象，对象中保存了键值对的值。

### 8.4.1 编码转换
当哈希对象可以同时满足两个一下条件，则使用ziplist编码。否则使用hashtable
- 哈希对象保存的所有键值对的键和值字符串长度都小于64字节
- 哈希对象保存的键值对数量小于512

### 8.4.2 哈希命令的实现
HSET，HGET，HEXISTS，HDEL，HLEN，HGETALL

## 8.5 集合对象
- 集合对象的编码可以是intset或者hashtable
- intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面
- hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则设为NULL
- SADD指令

### 8.5.1 编码的转换
当集合对相关同时满足以下两个条件，对象使用intset编码，不满足则使用hashtable
- 集合对象保存的所有元素都是整数值
- 集合对象保存的元素数量不超过512个

### 8.5.2 集合命令的实现
SADD，SCARD，SISMEMBER，SMEMBERS，SRANDMEMBER，SPOP，SREM

## 8.6 有序集合对象
- 有序集合的编码可以是ziplist或者skiplist
- ziplist编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个保存元素的分值。分数低的在表头，分数高的在表尾
- ZADD指令
- skiplist编码的有序集合列表使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表。zset中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点保存了一个集合元素。跳跃表节点object属性保存了元素的成员，节点score属性保存了分值。zset结构中的dict字典为有序集合创建了一个从成员到分数的映射。
- 有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是double。两种数据结构都会使用指针共享相同元素的成员和分值。

### 8.6.1 编码的转换
当有序集合对象可以同时满足以下两个条件，使用ziplist，否则使用skiplist
- 有序集合保存的元素数量小于128个
- 有序集合保存的所有元素成员的长度都小于64字节

### 8.6.2 有序集合命令的实现
ZADD，ZCARD，ZCOUNT，ZRANGE，ZREVRANGE，ZRANK，ZREEM，ZSCORE

## 8.7 类型检查与命令多态
- 对任何键都可以执行：DEL、EXPIRE、RENAME、TYPE、OBJECT
- SET、GET、APPEND、STRLEN只能对字符串键执行
- HDEL、HSET、HGET、LEN只能对哈希键执行
- RPUSH、LPOP、LINSERT、LLEN只能对列表建
- SADD、SPOP、SINTER、SCARD只能对集合键执行
- ZADD、ZCARD、ZRANK、ZSCORE只能对有序集合键执行

### 8.7.1 类型检查的实现
举个例子：客户端发送LLEN <key>命令，服务器检查键key的值对象是否列表对象，是则对键key执行LLEN命令，否则返回一个类型错误。

### 8.7.2 多态命令的实现
我们可以认为LEN命令是多态的，只要执行LLEN命令的是列表键，那么无论值对象使用的是ziplist编码还是linkedlist编码，命令都能正常运行。

## 8.8 内存回收
- C语言并不具备自动回收功能，Redis在自己的对象系统中构建了一个引用计数技术实现内存回收机制。redisObject的refcount属性
- 创建一个新对象，refcount为1，被一个应用程序使用则加1，不再被程序使用则减1，引用值变为0，对象所占用内存会被释放
