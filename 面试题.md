# 面试题

## 面试
### 阿里巴巴
#### 大文娱
- RDB和AOF区别

## 面经
### 猿辅导
#### 付新河
- 使用容量为N的数组实现N/L个容量为L的队列的入队出队操作
- 给边长输出一个顺时针的矩阵：
给边长4
1   2   3   4
5   6   7   8
9  10 11 12
13 14 15 16
- 给定字符串，把其中的字母倒序，其他字符不变，例如：$ab&cd >  $dc&ba
- https://leetcode.com/problems/house-robber/description/ 就是链接里的题
- 一个无序 可重复的整数数组，找到第一个缺失的正整数arr[1,2,3,3] return 4
- 实现一个LRU算法;查找的时间复杂度O(1);插入的时间复杂度也是O(1);空间不做要求。;Class LRU{ query(int value) insert(int value)}
- 二叉树节点间最大距离
- N个有序数组merge一个有序数组
- 复杂链表复制
- Synchronized，Lock，Kafka，Zookeeper
- https://blog.csdn.net/Fan0628/article/details/99715419?ops_request_misc=&request_id=&biz_id=102&utm_term=猿辅导面经&utm_medium=dis


## 理论
### GoLang
#### 内存管理
- 内存分配 http://legendtkl.com/2017/04/02/golang-alloc/
  1. 内存管理基于 tcmalloc
  2. 一个 Goroutine 的运行需要 G + P + M 三部分结合起来
  3. 如果一个变量被取地址，那么它就有可能被分配到堆上。然而，还要对这些变量做逃逸分析，如果函数 return 之后，变量不再被引用，则将其分配到栈上。
  4. mcache: per-P cache，可以认为是 local cache。
  5. mcentral: 全局 cache，mcache 不够用的时候向 mcentral 申请。
  6. mheap: 当 mcentral 也不够用的时候，通过 mheap 向操作系统申请。
- 垃圾回收方法 http://legendtkl.com/2017/04/28/golang-gc/
  1. 经典GC方法
    1. 引用计数：指针指向加1，删除减1，为0则回收
    2. 标注-清扫：标记阶段表明所有的存活单元，清扫阶段将垃圾单元回收
    3. 节点复制：整个堆等分为两个半区，一个包含现有数据，另一个包含已被废弃的数据
    4. 分代收集：将对象按生命周期长短存放到堆上的两个（或者更多）区域，生命周期长则新生代->老生代
  2. GoLang GC
    1. 在堆上分配大于 32K byte 对象的时候进行检测此时是否满足垃圾回收条件
    2. 当前堆上的活跃对象大于我们初始化时候设置的 GC 触发阈值
    3. 三色标记法，所有对象最开始都是白色，从 root 开始找到所有可达对象，标记为灰色，放入待处理队列。遍历灰色对象队列，将其引用对象标记为灰色放入待处理队列，自身标记为黑色。处理完灰色对象队列，执行清扫工作。

### 操作系统
#### 进程与线程
- 进程与线程区别
- 进程的状态
- 进程有哪些数据
- 进程的通信方式
- 进程调度算法

#### 内存管理
- 页面置换算法？

### MySQL
#### MySQL架构与历史
- InnoDB和MyISAM对比
- 事务的四大特性
- 事务的隔离级别

### Redis
#### 数据结构与对象
- 有哪些基础数据结构

#### 单机数据库的实现
- AOF和RDB区别
- Redis和MySQL保持数据一致
- Redis雪崩，穿透，击穿
  1. 缓存雪崩：就是指缓存中大批量热点数据过期后系统涌入大量查询请求
  2. 缓存穿透：恶意发送缓存中查不到的数据
  3. 缓存击穿：某个 key 非常热点，访问非常频繁，当这个key在失效的瞬间，大量的请求就击穿了缓存
